[{"content":"This book introduces the Python programming language. Python is a popular open source programming language used for both standalone programs and scripting applications in a wide variety of domains. It is free, portable, powerful, and remarkably easy and fun to use. Programmers from every corner of the software industry have found Python’s focus on developer productivity and software quality to be a strategic advantage in projects both large and small.\nIs Python a “Scripting Language”? Python is a general-purpose programming language that is often applied in scripting roles. It is commonly defined as an object-oriented scripting language—a definition that blends support for OOP with an overall orientation toward scripting roles. In fact, people often use the word “script” instead of “program” to describe a Python code file. In this book, the terms “script” and “program” are used interchangeably, with a slight preference for “script” to describe a simpler top-level file and “program” to refer to a more sophisticated multifile application.\nWho Uses Python Today? At this writing, the best estimate anyone can seem to make of the size of the Python user base is that there are roughly 1 million Python users around the world today (plus or minus a few). This estimate is based on various statistics, like download rates and developer surveys. Because Python is open source, a more exact count is difficult; there are no license registrations to tally. Moreover, Python is automatically included with Linux distributions, Macintosh computers, and some products and hardware, further clouding the user-base picture. By individual users, Python is also being applied in real revenue-generating products by real companies. For instance:\nGoogle makes extensive use of Python in its web search systems and employs Python’s creator. YouTube is largely written in Python. The popular BitTorrent peer-to-peer file sharing system is a Python program. Google’s popular App Engine web development framework uses Python as its application language. EVE Online, a Massively Multiplayer Online Game (MMOG), makes extensive use of Python. Maya, a powerful integrated 3D modeling and animation system, provides a Python scripting API. Intel, Cisco, Hewlett-Packard, Seagate, Qualcomm, and IBM use Python for hardware testing. Industrial Light \u0026amp; Magic, Pixar, and others use Python in the production of animated movies. JPMorgan Chase, UBS, Getco, and Citadel apply Python for financial market forecasting. NASA, Los Alamos, Fermilab, JPL, and others use Python for scientific programming tasks. iRobot uses Python to develop commercial robotic devices. ESRI uses Python as an end-user customization tool for its popular GIS mapping products. The NSA uses Python for cryptography and intelligence analysis. The IronPort email server product uses more than 1 million lines of Python code to do its job. The One Laptop Per Child (OLPC) project builds its user interface and activity model in Python. What Can I Do with Python? Python is useful for accomplishing real-world tasks. It’s commonly used in a variety of domains, as a tool for scripting other components and implementing standalone programs. In fact, as a general-purpose language, Python’s roles are virtually unlimited: you can use it for everything from website development and gaming to robotics and spacecraft control. However, the most common Python roles currently seem to fall into a few broad categories. The next few sections describe some of Python’s most common applications today, as well as tools used in each domain. We will not be able to explore the tools mentioned here in any depth—if you are interested in any of these topics, see the Python website or other resources for more details.\nSystems Programming Python’s built-in interfaces to operating-system services make it ideal for writing portable, maintainable system-administration tools and utilities (sometimes called shell tools). Python programs can search files and directory trees, launch other programs, do parallel processing with processes and threads, and so on. Python’s standard library comes with POSIX bindings and support for all the usual OS tools: environment variables, files, sockets, pipes, processes, multiple threads, regular expression pattern matching, command-line arguments, standard stream interfaces, shell-command launchers, filename expansion, and more. In addition, the bulk of Python’s system interfaces are designed to be portable; for example, a script that copies directory trees typically runs unchanged on all major Python platforms. The Stackless Python system, used by EVE Online, also offers advanced solutions to multiprocessing requirements.\nGUIs Python’s simplicity and rapid turnaround also make it a good match for graphical user interface programming. Python comes with a standard object-oriented interface to the Tk GUI API called tkinter (Tkinter in 2.6) that allows Python programs to implement portable GUIs with a native look and feel. Python/tkinter GUIs run unchanged on Microsoft Windows, X Windows (on Unix and Linux), and the Mac OS (both Classic and OS X). A free extension package, PMW, adds advanced widgets to the tkinter toolkit. In addition, the wxPython GUI API, based on a C++ library, offers an alternative toolkit for constructing portable GUIs in Python. Higher-level toolkits such as PythonCard and Dabo are built on top of base APIs such as wxPython and tkinter. With the proper library, you can also use GUI support in other toolkits in Python, such as Qt with PyQt, GTK with PyGTK, MFC with PyWin32, .NET with IronPython, and Swing with Jython or JPype. For applications that run in web browsers or have simple interface requirements, both Jython and Python web frameworks and server-side CGI scripts provide additional user interface options.\nInternet Scripting Python comes with standard Internet modules that allow Python programs to perform a wide variety of networking tasks, in client and server modes. Scripts can communicate over sockets; extract form information sent to server-side CGI scripts; transfer files by FTP; parse, generate, and analyze XML files; send, receive, compose, and parse email; fetch web pages by URLs; parse the HTML and XML of fetched web pages; and communicate over XML-RPC, SOAP, and Telnet; and more. Python’s libraries make these tasks remarkably simple. In addition, a large collection of third-party tools are available on the Web for doing Internet programming in Python. For instance, the HTMLGen system generates HTML files from Python class-based descriptions, the mod_python package runs Python efficiently within the Apache web server and supports server-side templating with its Python Server Pages, and the Jython system provides for seamless Python/Java integration and supports coding of server-side applets that run on clients. In addition, full-blown web development framework packages for Python, such as Django, TurboGears, web2py, Pylons, Zope, and WebWare, support quick construction of full-featured and production-quality websites with Python. Many of these include features such as object-relational mappers, a Model/View/Controller architecture, server-side scripting and templating, and AJAX support, to provide complete and enterprise-level web development solutions.\nComponent Integration We discussed the component integration role earlier when describing Python as a control language. Python’s ability to be extended by and embedded in C and C++ systems makes it useful as a flexible glue language for scripting the behavior of other systems and components. For instance, integrating a C library into Python enables Python to test and launch the library’s components, and embedding Python in a product enables onsite customizations to be coded without having to recompile the entire product (or ship its source code at all). Tools such as the SWIG and SIP code generators can automate much of the work needed to link compiled components into Python for use in scripts, and the Cython system allows coders to mix Python and C-like code. Larger frameworks, such as Python’s COM support on Windows, the Jython Java-based implementation, the IronPython .NET-based implementation, and various CORBA toolkits for Python, provide alternative ways to script components. On Windows, for example, Python scripts can use frameworks to script Word and Excel.\nDatabase Programming For traditional database demands, there are Python interfaces to all commonly used relational database systems—Sybase, Oracle, Informix, ODBC, MySQL, PostgreSQL, SQLite, and more. The Python world has also defined a portable database API for accessing SQL database systems from Python scripts, which looks the same on a variety of underlying database systems. For instance, because the vendor interfaces implement the portable API, a script written to work with the free MySQL system will work largely unchanged on other systems (such as Oracle); all you have to do is replace the underlying vendor interface. Python’s standard pickle module provides a simple object persistence system—it allows programs to easily save and restore entire Python objects to files and file-like objects. On the Web, you’ll also find a third-party open source system named ZODB that provides a complete object-oriented database system for Python scripts, and others (such as SQLObject and SQLAlchemy) that map relational tables onto Python’s class model. Furthermore, as of Python 2.5, the in-process SQLite embedded SQL database engine is a standard part of Python itself.\nRapid Prototyping To Python programs, components written in Python and C look the same. Because of this, it’s possible to prototype systems in Python initially, and then move selected components to a compiled language such as C or C++ for delivery.\nNumeric and Scientific Programming The NumPy numeric programming extension for Python mentioned earlier includes such advanced tools as an array object, interfaces to standard mathematical libraries, and much more. By integrating Python with numeric routines coded in a compiled language for speed, NumPy turns Python into a sophisticated yet easy-to-use numeric programming tool that can often replace existing code written in traditional compiled languages.\nGaming, Images, Serial Ports, XML, Robots, and More Python is commonly applied in more domains than can be mentioned here. For example, you can do:\nGame programming and multimedia with the pygame system. Serial port communication on Windows, Linux, and more with the PySerial Extension. Image processing with PIL, PyOpenGL, Blender, Maya, and others. Robot control programming with the PyRo toolkit. XML parsing with the xml library package, the xmlrpclib module, and third-party extensions. Artificial intelligence programming with neural network simulators and expert system shells. Natural language analysis with the NLTK package. You can even play solitaire with the PySol program. You will find support for many such fields at the PyPI website and via web searches (search Google or Python.org for links).\nMany of these specific domains are largely just instances of Python’s component integration role in action again.\nChapter Summary Introduction to Python:\nPython is introduced as a popular, open source programming language that is both powerful and easy to learn. It is designed to boost developer productivity and is suitable for both standalone programs and scripting applications.\nScripting and Programming:\nThe chapter clarifies that while Python is a general-purpose language, it is often used in scripting roles. The terms “script” and “program” are used interchangeably, with “script” typically referring to simpler, single-file applications and “program” referring to larger, multifile projects.\nUser Base and Industry Adoption:\nWith roughly 1 million users worldwide, Python’s user base includes individuals and major companies alike. It is employed by organizations such as Google, YouTube, NASA, and many others for diverse applications—from web development and scientific research to finance and multimedia production.\nWide Range of Applications:\nPython is versatile, supporting various domains including:\nSystems Programming: Portable system-administration tools and utilities. Graphical User Interfaces (GUIs): Using libraries like tkinter and wxPython for cross-platform applications. Internet Scripting: Networking, web development frameworks, and server-side applications. Component Integration: Acting as a glue language to integrate C/C++ libraries and other systems. Database Programming: Interfaces for popular relational databases and object persistence. Rapid Prototyping and Scientific Computing: Enabling quick development and numerical analysis with tools like NumPy. Additional Domains: Gaming, image processing, robotics, and more. Extensibility and Community Support:\nPython’s rich standard library, coupled with a vast ecosystem of third-party modules and frameworks, makes it a flexible tool for addressing a wide range of real-world problems. This extensibility is one of the key reasons for its widespread adoption across different industries.\n","permalink":"/chapters/chapter-1/","summary":"This chapter covers the basics of the subject\u0026hellip;","title":"Chapter 1: Introduction to Python"},{"content":"Introducing the Python Interpreter Python is a software package called an interpreter—a program that executes other programs. When you write a Python program, the Python interpreter reads your code and carries out the instructions it contains.\nAfter installation on your machine, the Python package generates a few components—minimally, an interpreter and a support library. Depending on how you use it, the Python interpreter may be an executable program or a set of libraries linked into another program. The Python code you write must always be run by this interpreter. To enable that, you must install a Python interpreter on your computer.\nWindows users: Fetch and run a self-installing executable file that puts Python on their machines. Simply double-click and say Yes or Next at all prompts. Python can be downloaded from the Python website or through various other distribution channels. Always check whether Python is already present before installing it. The Programmer’s View In its simplest form, a Python program is just a text file containing Python statements. For example, the following file, named script0.py, is one of the simplest Python scripts, yet it functions as a complete program:\nPrint (\u0026#39;hello world\u0026#39;) print (2 ** 100) Byte Code Compilation When you execute a Python program, the interpreter first compiles your source code into a format known as byte code. This compilation step translates each source statement into a set of lower-level, platform-independent instructions. Byte code execution is faster than running the original source code line by line. If the Python process has write access, it stores this compiled byte code in files ending with a .pyc extension. These files are created in the same directory as your source code after you run your programs.\nThe Python Virtual Machine (PVM) Once your program has been compiled to byte code (or loaded from existing .pyc files), it is handed off to the Python Virtual Machine (PVM) for execution. The PVM is essentially a loop that iterates through your byte code instructions one by one, performing their operations. It serves as the runtime engine of Python—integral to the Python system and responsible for actually running your scripts. In essence, the PVM is the final stage of the Python interpreter.\nFigure 2-1: Python’s traditional runtime execution model – source code is automatically compiled to byte code, which is then interpreted by the Python Virtual Machine.\nChapter Summary Python Interpreter:\nActs as the core software that executes Python programs. It reads your source code and runs the instructions contained within it.\nThe Programmer’s View:\nA Python program is simply a text file of statements. Even a minimal script, like one that prints a message or calculates a power, is a complete program.\nByte Code Compilation:\nPython automatically compiles source code into a lower-level byte code, stored as .pyc files, to enhance execution speed.\nPython Virtual Machine (PVM):\nThe PVM is the runtime engine that executes the byte code in a continuous loop, forming the final step in running your Python programs.\n","permalink":"/chapters/chapter-2/","summary":"\u003ch2 id=\"introducing-the-python-interpreter\"\u003eIntroducing the Python Interpreter\u003c/h2\u003e\n\u003cp\u003ePython is a software package called an interpreter—a program that executes other programs. When you write a Python program, the Python interpreter reads your code and carries out the instructions it contains.\u003c/p\u003e\n\u003cp\u003eAfter installation on your machine, the Python package generates a few components—minimally, an interpreter and a support library. Depending on how you use it, the Python interpreter may be an executable program or a set of libraries linked into another program. The Python code you write must always be run by this interpreter. To enable that, you must install a Python interpreter on your computer.\u003c/p\u003e","title":"Chapter 2: How Python Runs Programs"},{"content":"There are a variety of ways to tell Python to execute the code you type. Along the way, you’ll learn how to type code interactively and how to save it in files to be run with system command lines, icon clicks, module imports and reloads, exec calls, menu options in GUIs such as IDLE, and more.\nThe Interactive Prompt Perhaps the simplest way to run Python programs is to type them at Python’s interactive command line, sometimes called the interactive prompt. There are a variety of ways to start this command line: in an IDE, from a system console, and so on. Assuming the interpreter is installed as an executable program on your system, the most platform-neutral way to start an interactive interpreter session is usually just to type python at your operating system’s prompt, without any arguments.\nFor example:\n% python Python 3.0.1 (r301:69561, Feb 13 2009, 20:04:18) [MSC v.1500 32 bit (Intel)] ... Type \u0026#34;help\u0026#34;, \u0026#34;copyright\u0026#34;, \u0026#34;credits\u0026#34; or \u0026#34;license\u0026#34; for more information. \u0026gt;\u0026gt;\u0026gt; Running Code Interactively However it’s started, the Python interactive session begins by printing two lines of informational text (which I’ll omit from most of this book’s examples to save space), then prompts for input with \u0026gt;\u0026gt;\u0026gt; when it’s waiting for you to type a new Python statement or expression. When working interactively, the results of your code are displayed after the \u0026gt;\u0026gt;\u0026gt; lines after you press the Enter key.\nFor instance, here are the results of two Python print statements:\n% python \u0026gt;\u0026gt;\u0026gt; print(\u0026#39;Hello world!\u0026#39;) Hello world! \u0026gt;\u0026gt;\u0026gt; print(2 ** 8) 256 When coding interactively like this, you can type as many Python commands as you like. For example:\n\u0026gt;\u0026gt;\u0026gt; lumberjack = \u0026#39;okay\u0026#39; \u0026gt;\u0026gt;\u0026gt; lumberjack \u0026#39;okay\u0026#39; \u0026gt;\u0026gt;\u0026gt; 2 ** 8 256 \u0026gt;\u0026gt;\u0026gt; \u0026lt;== Use Ctrl-D (on Unix) or Ctrl-Z (on Windows) to exit % In this section, you’ll learn how to run files in the most basic way: by listing their names in a python command line entered at your computer’s system prompt. Though it might seem primitive to some, for many programmers a system shell command line window, together with a text editor window, constitutes as much of an integrated development environment as they will ever need.\nA First Script Open your favorite text editor (e.g., vi, Notepad, or the IDLE editor), and type the following statements into a new text file named script1.py:\n# A first Python script import sys # Load a library module print(2 ** 100) # Raise 2 to a power x = \u0026#39;Spam!\u0026#39; print(x * 8) # String repetition print(sys.platform) # Print the system platform You shouldn’t worry too much about this file’s code, but as a brief description, this file:\nImports a Python module (libraries of additional tools) to fetch the name of the platform. Runs three print function calls to display the script’s results. Uses a variable named x, created when it’s assigned, to hold onto a string object. Applies various object operations that we’ll begin studying. The sys.platform here is just a string that identifies the kind of computer you’re working on; it lives in a standard Python module called sys, which you must import to load.\nRunning Files with Command Lines You can ask Python to run it by listing its full filename as the first argument to a python command, typed at the system shell prompt:\n% python script1.py win32 1267650600228229401496703205376 Spam!Spam!Spam!Spam!Spam!Spam!Spam!Spam! The Input Trick If you need your script’s output to stick around when you launch it with an icon click, simply put a call to the built-in input function at the very bottom of the script.\nFor example:\n# A first Python script import sys # Load a library module print(sys.platform) print(2 ** 100) # Raise 2 to a power x = \u0026#39;Spam!\u0026#39; print(x * 8) # String repetition input() # \u0026lt;== ADDED In general, input() reads the next line of standard input, waiting if there is none yet available. The net effect in this context will be to pause the script, thereby keeping the output window shown in Figure 3-2 open until you press the Enter key.\nFigure 3-1: When you click a program’s icon on Windows, you will be able to see its printed output if you include an input() call at the very end of the script. But you only need to do so in this context!\nThe Attributes Imports and reloads provide a natural program launch option because import operations execute files as a last step. In the broader scheme of things, though, modules serve the role of libraries of tools. More generally, a module is mostly just a package of variable names, known as a namespace. The names within that package are called attributes—an attribute is simply a variable name that is attached to a specific object (like a module).\nExternally, a module file’s names can be fetched with two Python statements, import and from, as well as the reload call.\nTo illustrate, use a text editor to create a one-line Python module file called myfile.py with the following contents:\ntitle = \u0026#34;The Meaning of Life\u0026#34; This may be one of the world’s simplest Python modules (it contains a single assignment statement), but it’s enough to illustrate the point. When this file is imported, its code is run to generate the module’s attribute. The assignment statement creates a module attribute named title.\nYou can access this module’s title attribute in other components in two different ways.\nFirst, you can load the module as a whole with an import statement, and then qualify the module name with the attribute name to fetch it:\n% python \u0026gt;\u0026gt;\u0026gt; import myfile # Run file; load module as a whole \u0026gt;\u0026gt;\u0026gt; print(myfile.title) # Use its attribute names: \u0026#39;.\u0026#39; to qualify The Meaning of Life In general, the dot expression syntax object.attribute lets you fetch any attribute attached to any object, and this is a very common operation in Python code. Here, we’ve used it to access the string variable title inside the module myfile—in other words, myfile.title.\nAlternatively, you can fetch (really, copy) names out of a module with from statements:\n% python \u0026gt;\u0026gt;\u0026gt; from myfile import title # Run file; copy its names \u0026gt;\u0026gt;\u0026gt; print(title) # Use name directly: no need to qualify The Meaning of Life The IDLE User Interface So far, we’ve seen how to run Python code with the interactive prompt, system command lines, icon clicks, and module imports and exec calls. If you’re looking for something a bit more visual, IDLE provides a graphical user interface for doing Python development, and it’s a standard and free part of the Python system. It is usually referred to as an integrated development environment (IDE) because it binds together various development tasks into a single view.\nIn short, IDLE is a GUI that lets you edit, run, browse, and debug Python programs, all from a single interface. Moreover, because IDLE is a Python program that uses the tkinter GUI toolkit, it runs portably on most Python platforms, including Microsoft Windows and X Windows.\nIDLE Basics Let’s jump right into an example. IDLE is easy to start under Windows—it has an entry in the Start button menu for Python, and it can also be selected by right-clicking on a Python program icon.\nFigure 3-2: The main Python shell window of the IDLE development GUI, shown here running on Windows. Use the File menu to begin (New Window) or change (Open\u0026hellip;) a source file; use the text edit window’s Run menu to run the code in that window (Run Module).\n","permalink":"/chapters/chapter-3/","summary":"\u003cp\u003eThere are a variety of ways to tell Python to execute the code you type. Along the way, you’ll learn how to type code interactively and how to save it in files to be run with system command lines, icon clicks, module imports and reloads, \u003ccode\u003eexec\u003c/code\u003e calls, menu options in GUIs such as IDLE, and more.\u003c/p\u003e\n\u003ch2 id=\"the-interactive-prompt\"\u003eThe Interactive Prompt\u003c/h2\u003e\n\u003cp\u003ePerhaps the simplest way to run Python programs is to type them at Python’s interactive command line, sometimes called the interactive prompt. There are a variety of ways to start this command line: in an IDE, from a system console, and so on. Assuming the interpreter is installed as an executable program on your system, the most platform-neutral way to start an interactive interpreter session is usually just to type \u003ccode\u003epython\u003c/code\u003e at your operating system’s prompt, without any arguments.\u003cbr\u003e\nFor example:\u003c/p\u003e","title":"Chapter 3: How You Run the Programs"},{"content":"Python programs can be decomposed into modules, statements, expressions, and objects, as follows:\nPrograms are composed of modules. Modules contain statements. Statements contain expressions. Expressions create and process objects. Python’s Core Data Types Table 1 previews Python’s built-in object types and some of the syntax used to code their literals—that is, the expressions that generate these objects.\nNumbers Numbers in Python support the normal mathematical operations. For instance, the plus sign (+) performs addition, a star (*) is used for multiplication, and two stars (**) are used for exponentiation:\n\u0026gt;\u0026gt;\u0026gt; 123 + 222 # Integer addition 345 \u0026gt;\u0026gt;\u0026gt; 1.5 * 4 # Floating-point multiplication 6.0 \u0026gt;\u0026gt;\u0026gt; 2 ** 100 # 2 to the power 100 1267650600228229401496703205376 You can, for instance, compute 2 to the power 1,000,000 as an integer in Python, but you probably shouldn’t try to print the result—with more than 300,000 digits, you may be waiting awhile!\n\u0026gt;\u0026gt;\u0026gt; len(str(2 ** 1000000)) 301030 # How many digits in a really BIG number? Besides expressions, there are a handful of useful numeric modules that ship with Python—modules are just packages of additional tools that we import to use:\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; math.pi 3.1415926535897931 \u0026gt;\u0026gt;\u0026gt; math.sqrt(85) 9.2195444572928871 The math module contains more advanced numeric tools as functions, while the random module performs random number generation and random selections:\n\u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.random() 0.59268735266273953 \u0026gt;\u0026gt;\u0026gt; random.choice([1, 2, 3, 4]) 1 Strings For example, if we have a four-character string, we can verify its length with the built-in len function and fetch its components with indexing expressions:\n\u0026gt;\u0026gt;\u0026gt; S = \u0026#39;Spam\u0026#39; \u0026gt;\u0026gt;\u0026gt; len(S) 4 \u0026gt;\u0026gt;\u0026gt; S[0] \u0026#39;S\u0026#39; \u0026gt;\u0026gt;\u0026gt; S[1] \u0026#39;p\u0026#39; In Python, we can also index backward, from the end—positive indexes count from the left, and negative indexes count back from the right:\n\u0026gt;\u0026gt;\u0026gt; S[-1] \u0026#39;m\u0026#39; \u0026gt;\u0026gt;\u0026gt; S[-2] \u0026#39;a\u0026#39; Formally, a negative index is simply added to the string’s size, so the following two operations are equivalent:\n\u0026gt;\u0026gt;\u0026gt; S[-1] \u0026#39;m\u0026#39; \u0026gt;\u0026gt;\u0026gt; S[len(S)-1] \u0026#39;m\u0026#39; In addition to simple positional indexing, sequences also support a more general form of indexing known as slicing, which is a way to extract an entire section (slice) in a single step. For example:\n\u0026gt;\u0026gt;\u0026gt; S \u0026#39;Spam\u0026#39; \u0026gt;\u0026gt;\u0026gt; S[1:3] \u0026#39;pa\u0026#39; \u0026gt;\u0026gt;\u0026gt; S[0:3] \u0026#39;Spa\u0026#39; \u0026gt;\u0026gt;\u0026gt; S[:3] \u0026#39;Spa\u0026#39; \u0026gt;\u0026gt;\u0026gt; S[:-1] \u0026#39;Spa\u0026#39; \u0026gt;\u0026gt;\u0026gt; S[:] \u0026#39;Spam\u0026#39; Strings also support concatenation with the plus sign (+) and repetition:\n\u0026gt;\u0026gt;\u0026gt; S \u0026#39;Spam\u0026#39; \u0026gt;\u0026gt;\u0026gt; S + \u0026#39;xyz\u0026#39; \u0026#39;Spamxyz\u0026#39; \u0026gt;\u0026gt;\u0026gt; S * 8 \u0026#39;SpamSpamSpamSpamSpamSpamSpamSpam\u0026#39; Notice that the plus sign (+) means different things for different objects: addition for numbers, and concatenation for strings.\nType-Specific Methods Strings have operations all their own, available as methods—functions attached to the object. For example, the string find method is the basic substring search operation, and the replace method performs global searches and replacements:\n\u0026gt;\u0026gt;\u0026gt; S.find(\u0026#39;pa\u0026#39;) 1 \u0026gt;\u0026gt;\u0026gt; S.replace(\u0026#39;pa\u0026#39;, \u0026#39;XYZ\u0026#39;) \u0026#39;SXYZm\u0026#39; \u0026gt;\u0026gt;\u0026gt; S \u0026#39;Spam\u0026#39; Other methods split a string into substrings on a delimiter, perform case conversions, test the content of the string (such as isalpha, isdigit, etc.), and strip whitespace characters off the ends of the string:\n\u0026gt;\u0026gt;\u0026gt; line = \u0026#39;aaa,bbb,ccccc,dd\u0026#39; \u0026gt;\u0026gt;\u0026gt; line.split(\u0026#39;,\u0026#39;) [\u0026#39;aaa\u0026#39;, \u0026#39;bbb\u0026#39;, \u0026#39;ccccc\u0026#39;, \u0026#39;dd\u0026#39;] \u0026gt;\u0026gt;\u0026gt; S = \u0026#39;spam\u0026#39; \u0026gt;\u0026gt;\u0026gt; S.upper() \u0026#39;SPAM\u0026#39; \u0026gt;\u0026gt;\u0026gt; S.isalpha() True \u0026gt;\u0026gt;\u0026gt; line = \u0026#39;aaa,bbb,ccccc,dd\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; line = line.rstrip() \u0026gt;\u0026gt;\u0026gt; line \u0026#39;aaa,bbb,ccccc,dd\u0026#39; Strings also support an advanced substitution operation known as formatting, available as both an expression and a string method:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;%s, eggs, and %s\u0026#39; % (\u0026#39;spam\u0026#39;, \u0026#39;SPAM!\u0026#39;) \u0026#39;spam, eggs, and SPAM!\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;{0}, eggs, and {1}\u0026#39;.format(\u0026#39;spam\u0026#39;, \u0026#39;SPAM!\u0026#39;) \u0026#39;spam, eggs, and SPAM!\u0026#39; Getting Help You can always call the built-in dir function, which returns a list of all the attributes available for a given object:\n\u0026gt;\u0026gt;\u0026gt; dir(S) [\u0026#39;__add__\u0026#39;, \u0026#39;__class__\u0026#39;, \u0026#39;__contains__\u0026#39;, \u0026#39;__delattr__\u0026#39;, \u0026#39;__doc__\u0026#39;, \u0026#39;__eq__\u0026#39;, \u0026#39;__format__\u0026#39;, \u0026#39;__ge__\u0026#39;, \u0026#39;__getattribute__\u0026#39;, \u0026#39;__getitem__\u0026#39;, \u0026#39;__getnewargs__\u0026#39;, \u0026#39;__gt__\u0026#39;, \u0026#39;__hash__\u0026#39;, \u0026#39;__init__\u0026#39;, \u0026#39;__iter__\u0026#39;, \u0026#39;__le__\u0026#39;, \u0026#39;__len__\u0026#39;, \u0026#39;__lt__\u0026#39;, \u0026#39;__mod__\u0026#39;, \u0026#39;__mul__\u0026#39;, \u0026#39;__ne__\u0026#39;, \u0026#39;__new__\u0026#39;, \u0026#39;__reduce__\u0026#39;, \u0026#39;__reduce_ex__\u0026#39;, \u0026#39;__repr__\u0026#39;, \u0026#39;__rmod__\u0026#39;, \u0026#39;__rmul__\u0026#39;, \u0026#39;__setattr__\u0026#39;, \u0026#39;__sizeof__\u0026#39;, \u0026#39;__str__\u0026#39;, \u0026#39;__subclasshook__\u0026#39;, \u0026#39;_formatter_field_name_split\u0026#39;, \u0026#39;_formatter_parser\u0026#39;, \u0026#39;capitalize\u0026#39;, \u0026#39;center\u0026#39;, \u0026#39;count\u0026#39;, \u0026#39;encode\u0026#39;, \u0026#39;endswith\u0026#39;, \u0026#39;expandtabs\u0026#39;, \u0026#39;find\u0026#39;, \u0026#39;format\u0026#39;, \u0026#39;index\u0026#39;, \u0026#39;isalnum\u0026#39;, \u0026#39;isalpha\u0026#39;, \u0026#39;isdecimal\u0026#39;, \u0026#39;isdigit\u0026#39;, \u0026#39;isidentifier\u0026#39;, \u0026#39;islower\u0026#39;, \u0026#39;isnumeric\u0026#39;, \u0026#39;isprintable\u0026#39;, \u0026#39;isspace\u0026#39;, \u0026#39;istitle\u0026#39;, \u0026#39;isupper\u0026#39;, \u0026#39;join\u0026#39;, \u0026#39;ljust\u0026#39;, \u0026#39;lower\u0026#39;, \u0026#39;lstrip\u0026#39;, \u0026#39;maketrans\u0026#39;, \u0026#39;partition\u0026#39;, \u0026#39;replace\u0026#39;, \u0026#39;rfind\u0026#39;, \u0026#39;rindex\u0026#39;, \u0026#39;rjust\u0026#39;, \u0026#39;rpartition\u0026#39;, \u0026#39;rsplit\u0026#39;, \u0026#39;rstrip\u0026#39;, \u0026#39;split\u0026#39;, \u0026#39;splitlines\u0026#39;, \u0026#39;startswith\u0026#39;, \u0026#39;strip\u0026#39;, \u0026#39;swapcase\u0026#39;, \u0026#39;title\u0026#39;, \u0026#39;translate\u0026#39;, \u0026#39;upper\u0026#39;, \u0026#39;zfill\u0026#39;] To ask what they do, you can pass them to the help function:\n\u0026gt;\u0026gt;\u0026gt; help(S.replace) Pattern Matching Text pattern matching is an advanced tool outside this book’s scope, but to perform pattern matching in Python, import the re module. This module provides functions for searching, splitting, and replacing using regular expression patterns:\n\u0026gt;\u0026gt;\u0026gt; import re \u0026gt;\u0026gt;\u0026gt; match = re.match(\u0026#39;Hello[ \\t]*(.*)world\u0026#39;, \u0026#39;Hello Python world\u0026#39;) \u0026gt;\u0026gt;\u0026gt; match.group(1) \u0026#39;Python \u0026#39; This example searches for a substring that begins with the word \u0026ldquo;Hello,\u0026rdquo; followed by zero or more spaces or tabs, capturing the intermediate text up to \u0026ldquo;world.\u0026rdquo; For another example:\n\u0026gt;\u0026gt;\u0026gt; match = re.match(\u0026#39;/(.*)/(.*)/(.*)\u0026#39;, \u0026#39;/usr/home/lumberjack\u0026#39;) \u0026gt;\u0026gt;\u0026gt; match.groups() (\u0026#39;usr\u0026#39;, \u0026#39;home\u0026#39;, \u0026#39;lumberjack\u0026#39;) Sequence Operations Lists support all the sequence operations for strings; the results are usually lists instead of strings. For example, given a three-item list:\n\u0026gt;\u0026gt;\u0026gt; L = [123, \u0026#39;spam\u0026#39;, 1.23] \u0026gt;\u0026gt;\u0026gt; len(L) 3 You can index, slice, and concatenate lists:\n\u0026gt;\u0026gt;\u0026gt; L[0] 123 \u0026gt;\u0026gt;\u0026gt; L[:-1] [123, \u0026#39;spam\u0026#39;] \u0026gt;\u0026gt;\u0026gt; L + [4, 5, 6] [123, \u0026#39;spam\u0026#39;, 1.23, 4, 5, 6] \u0026gt;\u0026gt;\u0026gt; L [123, \u0026#39;spam\u0026#39;, 1.23] Type-Specific Operations on Lists Python’s lists are related to arrays in other languages, but they tend to be more powerful. Lists can contain objects of different types and have no fixed size—they can grow and shrink on demand:\n\u0026gt;\u0026gt;\u0026gt; L.append(\u0026#39;NI\u0026#39;) \u0026gt;\u0026gt;\u0026gt; L [123, \u0026#39;spam\u0026#39;, 1.23, \u0026#39;NI\u0026#39;] \u0026gt;\u0026gt;\u0026gt; L.pop(2) 1.23 \u0026gt;\u0026gt;\u0026gt; L [123, \u0026#39;spam\u0026#39;, \u0026#39;NI\u0026#39;] Other list methods include insert (to add an item at an arbitrary position) and remove (to delete an item by value). For example:\n\u0026gt;\u0026gt;\u0026gt; M = [\u0026#39;bb\u0026#39;, \u0026#39;aa\u0026#39;, \u0026#39;cc\u0026#39;] \u0026gt;\u0026gt;\u0026gt; M.sort() \u0026gt;\u0026gt;\u0026gt; M [\u0026#39;aa\u0026#39;, \u0026#39;bb\u0026#39;, \u0026#39;cc\u0026#39;] \u0026gt;\u0026gt;\u0026gt; M.reverse() \u0026gt;\u0026gt;\u0026gt; M [\u0026#39;cc\u0026#39;, \u0026#39;bb\u0026#39;, \u0026#39;aa\u0026#39;] Bounds Checking Although lists have no fixed size, Python does not allow you to reference items that are not present. Indexing or assigning to an index outside the current list range will raise an error:\n\u0026gt;\u0026gt;\u0026gt; L [123, \u0026#39;spam\u0026#39;, \u0026#39;NI\u0026#39;] \u0026gt;\u0026gt;\u0026gt; L[99] # IndexError: list index out of range \u0026gt;\u0026gt;\u0026gt; L[99] = 1 # IndexError: list assignment index out of range Nesting One nice feature of Python’s core data types is that they support arbitrary nesting. For example, a list can contain other lists to represent a matrix:\n\u0026gt;\u0026gt;\u0026gt; M = [ ... [1, 2, 3], ... [4, 5, 6], ... [7, 8, 9] ... ] \u0026gt;\u0026gt;\u0026gt; M [[1, 2, 3], [4, 5, 6], [7, 8, 9]] Access nested items as follows:\n\u0026gt;\u0026gt;\u0026gt; M[1] [4, 5, 6] \u0026gt;\u0026gt;\u0026gt; M[1][2] 6 Comprehensions List comprehensions provide a powerful way to create new lists by processing sequences. For example, to extract the second column of the matrix:\n\u0026gt;\u0026gt;\u0026gt; col2 = [row[1] for row in M] \u0026gt;\u0026gt;\u0026gt; col2 [2, 5, 8] Other examples include modifying items or filtering:\n\u0026gt;\u0026gt;\u0026gt; [row[1] + 1 for row in M] [3, 6, 9] \u0026gt;\u0026gt;\u0026gt; [row[1] for row in M if row[1] % 2 == 0] [2, 8] More examples:\n\u0026gt;\u0026gt;\u0026gt; diag = [M[i][i] for i in [0, 1, 2]] \u0026gt;\u0026gt;\u0026gt; diag [1, 5, 9] \u0026gt;\u0026gt;\u0026gt; doubles = [c * 2 for c in \u0026#39;spam\u0026#39;] \u0026gt;\u0026gt;\u0026gt; doubles [\u0026#39;ss\u0026#39;, \u0026#39;pp\u0026#39;, \u0026#39;aa\u0026#39;, \u0026#39;mm\u0026#39;] Generator comprehensions can produce results on demand:\n\u0026gt;\u0026gt;\u0026gt; G = (sum(row) for row in M) \u0026gt;\u0026gt;\u0026gt; next(G) 6 \u0026gt;\u0026gt;\u0026gt; next(G) 15 Using map to apply a function over a sequence:\n\u0026gt;\u0026gt;\u0026gt; list(map(sum, M)) [6, 15, 24] Set and dictionary comprehensions:\n\u0026gt;\u0026gt;\u0026gt; {sum(row) for row in M} {24, 6, 15} \u0026gt;\u0026gt;\u0026gt; {i: sum(M[i]) for i in range(3)} {0: 6, 1: 15, 2: 24} Additional examples:\n\u0026gt;\u0026gt;\u0026gt; [ord(x) for x in \u0026#39;spaam\u0026#39;] [115, 112, 97, 97, 109] \u0026gt;\u0026gt;\u0026gt; {ord(x) for x in \u0026#39;spaam\u0026#39;} {112, 97, 115, 109} \u0026gt;\u0026gt;\u0026gt; {x: ord(x) for x in \u0026#39;spaam\u0026#39;} {\u0026#39;a\u0026#39;: 97, \u0026#39;p\u0026#39;: 112, \u0026#39;s\u0026#39;: 115, \u0026#39;m\u0026#39;: 109} Dictionaries Python dictionaries are mappings that store objects by key rather than by position. For example, a dictionary literal:\n\u0026gt;\u0026gt;\u0026gt; D = {\u0026#39;food\u0026#39;: \u0026#39;Spam\u0026#39;, \u0026#39;quantity\u0026#39;: 4, \u0026#39;color\u0026#39;: \u0026#39;pink\u0026#39;} Accessing and modifying values:\n\u0026gt;\u0026gt;\u0026gt; D[\u0026#39;food\u0026#39;] \u0026#39;Spam\u0026#39; \u0026gt;\u0026gt;\u0026gt; D[\u0026#39;quantity\u0026#39;] += 1 \u0026gt;\u0026gt;\u0026gt; D {\u0026#39;food\u0026#39;: \u0026#39;Spam\u0026#39;, \u0026#39;color\u0026#39;: \u0026#39;pink\u0026#39;, \u0026#39;quantity\u0026#39;: 5} Creating a dictionary incrementally:\n\u0026gt;\u0026gt;\u0026gt; D = {} \u0026gt;\u0026gt;\u0026gt; D[\u0026#39;name\u0026#39;] = \u0026#39;Bob\u0026#39; \u0026gt;\u0026gt;\u0026gt; D[\u0026#39;job\u0026#39;] = \u0026#39;dev\u0026#39; \u0026gt;\u0026gt;\u0026gt; D[\u0026#39;age\u0026#39;] = 40 \u0026gt;\u0026gt;\u0026gt; D {\u0026#39;age\u0026#39;: 40, \u0026#39;job\u0026#39;: \u0026#39;dev\u0026#39;, \u0026#39;name\u0026#39;: \u0026#39;Bob\u0026#39;} \u0026gt;\u0026gt;\u0026gt; print(D[\u0026#39;name\u0026#39;]) Bob Nesting Revisited For more complex data, dictionaries can be nested. For example:\n\u0026gt;\u0026gt;\u0026gt; rec = { ... \u0026#39;name\u0026#39;: {\u0026#39;first\u0026#39;: \u0026#39;Bob\u0026#39;, \u0026#39;last\u0026#39;: \u0026#39;Smith\u0026#39;}, ... \u0026#39;job\u0026#39;: [\u0026#39;dev\u0026#39;, \u0026#39;mgr\u0026#39;], ... \u0026#39;age\u0026#39;: 40.5 ... } Accessing nested data:\n\u0026gt;\u0026gt;\u0026gt; rec[\u0026#39;name\u0026#39;] {\u0026#39;first\u0026#39;: \u0026#39;Bob\u0026#39;, \u0026#39;last\u0026#39;: \u0026#39;Smith\u0026#39;} \u0026gt;\u0026gt;\u0026gt; rec[\u0026#39;name\u0026#39;][\u0026#39;last\u0026#39;] \u0026#39;Smith\u0026#39; \u0026gt;\u0026gt;\u0026gt; rec[\u0026#39;job\u0026#39;] [\u0026#39;dev\u0026#39;, \u0026#39;mgr\u0026#39;] \u0026gt;\u0026gt;\u0026gt; rec[\u0026#39;job\u0026#39;][-1] \u0026#39;mgr\u0026#39; \u0026gt;\u0026gt;\u0026gt; rec[\u0026#39;job\u0026#39;].append(\u0026#39;janitor\u0026#39;) \u0026gt;\u0026gt;\u0026gt; rec {\u0026#39;name\u0026#39;: {\u0026#39;first\u0026#39;: \u0026#39;Bob\u0026#39;, \u0026#39;last\u0026#39;: \u0026#39;Smith\u0026#39;}, \u0026#39;job\u0026#39;: [\u0026#39;dev\u0026#39;, \u0026#39;mgr\u0026#39;, \u0026#39;janitor\u0026#39;], \u0026#39;age\u0026#39;: 40.5} Sorting Keys: for Loops Dictionaries do not maintain order, but you can sort the keys and iterate over them:\n\u0026gt;\u0026gt;\u0026gt; D = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; D {\u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3, \u0026#39;b\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt; Ks = list(D.keys()) \u0026gt;\u0026gt;\u0026gt; Ks.sort() \u0026gt;\u0026gt;\u0026gt; Ks [\u0026#39;a\u0026#39;, \u0026#39;b\u0026#39;, \u0026#39;c\u0026#39;] \u0026gt;\u0026gt;\u0026gt; for key in Ks: ... print(key, \u0026#39;=\u0026gt;\u0026#39;, D[key]) a =\u0026gt; 1 b =\u0026gt; 2 c =\u0026gt; 3 Alternatively, using the sorted function:\n\u0026gt;\u0026gt;\u0026gt; for key in sorted(D): ... print(key, \u0026#39;=\u0026gt;\u0026#39;, D[key]) a =\u0026gt; 1 b =\u0026gt; 2 c =\u0026gt; 3 Iteration and Optimization For loops and list comprehensions are the main ways to code repetitive tasks. For example, computing squares with a list comprehension:\n\u0026gt;\u0026gt;\u0026gt; squares = [x ** 2 for x in [1, 2, 3, 4, 5]] \u0026gt;\u0026gt;\u0026gt; squares [1, 4, 9, 16, 25] The equivalent for loop:\n\u0026gt;\u0026gt;\u0026gt; squares = [] \u0026gt;\u0026gt;\u0026gt; for x in [1, 2, 3, 4, 5]: ... squares.append(x ** 2) \u0026gt;\u0026gt;\u0026gt; squares [1, 4, 9, 16, 25] Tools like map and comprehensions are generally faster than for loops for large data sets.\nMissing Keys: if Tests Assigning to a new key grows a dictionary:\n\u0026gt;\u0026gt;\u0026gt; D = {\u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3, \u0026#39;b\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt; D[\u0026#39;e\u0026#39;] = 99 \u0026gt;\u0026gt;\u0026gt; D {\u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3, \u0026#39;b\u0026#39;: 2, \u0026#39;e\u0026#39;: 99} Attempting to access a nonexistent key results in an error:\n\u0026gt;\u0026gt;\u0026gt; D[\u0026#39;f\u0026#39;] # KeyError: \u0026#39;f\u0026#39; Test for key existence:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;f\u0026#39; in D False Using a default value with get:\n\u0026gt;\u0026gt;\u0026gt; value = D.get(\u0026#39;x\u0026#39;, 0) \u0026gt;\u0026gt;\u0026gt; value 0 \u0026gt;\u0026gt;\u0026gt; value = D[\u0026#39;x\u0026#39;] if \u0026#39;x\u0026#39; in D else 0 \u0026gt;\u0026gt;\u0026gt; value 0 Other Core Types Sets Sets are unordered collections of unique and immutable objects. Create sets using the built-in set function or set literals:\n\u0026gt;\u0026gt;\u0026gt; X = set(\u0026#39;spam\u0026#39;) \u0026gt;\u0026gt;\u0026gt; Y = {\u0026#39;h\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;} \u0026gt;\u0026gt;\u0026gt; X, Y ({\u0026#39;a\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;m\u0026#39;}, {\u0026#39;a\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;m\u0026#39;}) Set operations:\n\u0026gt;\u0026gt;\u0026gt; X \u0026amp; Y # Intersection {\u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;} \u0026gt;\u0026gt;\u0026gt; X | Y # Union {\u0026#39;a\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;s\u0026#39;, \u0026#39;h\u0026#39;, \u0026#39;m\u0026#39;} \u0026gt;\u0026gt;\u0026gt; X - Y # Difference {\u0026#39;p\u0026#39;, \u0026#39;s\u0026#39;} Set comprehensions are also supported:\n\u0026gt;\u0026gt;\u0026gt; {x ** 2 for x in [1, 2, 3, 4]} {16, 1, 4, 9} Additional Numeric Types Python includes decimal numbers and fraction numbers to address limitations of floating-point arithmetic:\n\u0026gt;\u0026gt;\u0026gt; 1 / 3 0.33333333333333331 \u0026gt;\u0026gt;\u0026gt; (2/3) + (1/2) 1.1666666666666665 Using the decimal module:\n\u0026gt;\u0026gt;\u0026gt; import decimal \u0026gt;\u0026gt;\u0026gt; d = decimal.Decimal(\u0026#39;3.141\u0026#39;) \u0026gt;\u0026gt;\u0026gt; d + 1 Decimal(\u0026#39;4.141\u0026#39;) \u0026gt;\u0026gt;\u0026gt; decimal.getcontext().prec = 2 \u0026gt;\u0026gt;\u0026gt; decimal.Decimal(\u0026#39;1.00\u0026#39;) / decimal.Decimal(\u0026#39;3.00\u0026#39;) Decimal(\u0026#39;0.33\u0026#39;) Using the fractions module:\n\u0026gt;\u0026gt;\u0026gt; from fractions import Fraction \u0026gt;\u0026gt;\u0026gt; f = Fraction(2, 3) \u0026gt;\u0026gt;\u0026gt; f + 1 Fraction(5, 3) \u0026gt;\u0026gt;\u0026gt; f + Fraction(1, 2) Fraction(7, 6) Booleans and None Python also includes Booleans and a special placeholder None:\n\u0026gt;\u0026gt;\u0026gt; 1 \u0026gt; 2, 1 \u0026lt; 2 (False, True) \u0026gt;\u0026gt;\u0026gt; bool(\u0026#39;spam\u0026#39;) True \u0026gt;\u0026gt;\u0026gt; X = None \u0026gt;\u0026gt;\u0026gt; print(X) None \u0026gt;\u0026gt;\u0026gt; L = [None] * 100 \u0026gt;\u0026gt;\u0026gt; L [None, None, None, None, ...] # A list of 100 Nones Examples (Object Types) Display a number rounded to two decimal places: print(round(num, 2)) Compute the square root of a number (requires import math): math.sqrt(num) Convert user input to a floating-point number: num = float(input(\u0026#34;Enter number: \u0026#34;)) Display pi (π) to 15 decimal places (requires import math): print(math.pi) Perform whole number division (e.g., 15 // 2 yields 7): x // y Find the remainder (e.g., 15 % 2 yields 1): x % y Ask the user to enter a number with lots of decimal places, multiply it by two, and display the answer. Update program 7 so that it displays the answer to two decimal places. Ask the user to enter an integer over 500, compute the square root, and display it to two decimal places. Display pi (π) to five decimal places. Ask the user to enter the radius of a circle and compute its area (π * radius^2). Ask for the radius and the depth of a cylinder and compute the total volume (circle area * depth) rounded to three decimal places. Ask the user to enter two numbers. Use whole number division to divide the first by the second and display the quotient and remainder in a user-friendly way. Display a message based on user input: if the user enters 1, prompt for the side length of a square and display its area; if 2, prompt for the base and height of a triangle and display its area; otherwise, display an error message. Chapter Summary Object Composition:\nPython programs are structured into modules, statements, expressions, and objects.\nCore Data Types:\nThe chapter covers numbers, strings, lists, dictionaries, sets, and other types, including decimals, fractions, Booleans, and None.\nOperations and Methods:\nIt explains arithmetic operations, string manipulations, sequence operations, and type-specific methods.\nData Structures:\nDetailed discussion of lists, dictionaries, and sets including indexing, slicing, nesting, comprehensions, and iteration.\nExamples:\nA series of examples demonstrate practical applications of these types and operations.\n","permalink":"/chapters/chapter-4/","summary":"\u003cp\u003ePython programs can be decomposed into modules, statements, expressions, and objects, as follows:\u003c/p\u003e\n\u003col\u003e\n\u003cli\u003ePrograms are composed of modules.\u003c/li\u003e\n\u003cli\u003eModules contain statements.\u003c/li\u003e\n\u003cli\u003eStatements contain expressions.\u003c/li\u003e\n\u003cli\u003eExpressions create and process objects.\u003c/li\u003e\n\u003c/ol\u003e\n\u003ch2 id=\"pythons-core-data-types\"\u003ePython’s Core Data Types\u003c/h2\u003e\n\u003cp\u003eTable 1 previews Python’s built-in object types and some of the syntax used to code their literals—that is, the expressions that generate these objects.\u003c/p\u003e\n\u003ch2 id=\"numbers\"\u003eNumbers\u003c/h2\u003e\n\u003cp\u003eNumbers in Python support the normal mathematical operations. For instance, the plus sign (\u003ccode\u003e+\u003c/code\u003e) performs addition, a star (\u003ccode\u003e*\u003c/code\u003e) is used for multiplication, and two stars (\u003ccode\u003e**\u003c/code\u003e) are used for exponentiation:\u003c/p\u003e","title":"Chapter 4: Object Types"},{"content":"Let’s get started by exploring our first data type category: Python’s numeric types.\nNumeric Type Basics A complete inventory of Python’s numeric toolbox includes:\nIntegers and floating-point numbers Complex numbers Fixed-precision decimal numbers Rational fraction numbers Sets Booleans Unlimited integer precision A variety of numeric built-ins and modules We will present a brief overview of how we write and process numbers in our scripts.\nNumeric Literals Among its basic types, Python provides integers (positive and negative whole numbers) and floating-point numbers (numbers with a fractional part, sometimes called \u0026ldquo;floats\u0026rdquo; for economy). Table 1 (not shown) illustrates what Python’s numeric types look like when written as literals.\nBuilt-in Numeric Tools Besides the built-in number literals, Python provides a set of tools for processing numeric objects:\nExpression operators: +, -, *, /, \u0026gt;\u0026gt;, **, \u0026amp;, etc. Built-in mathematical functions: pow, abs, round, int, hex, bin, etc. Utility modules: random, math, etc. Python Expression Operators Table 2 (not shown) lists all the operator expressions available in Python. Many are self-explanatory; for instance, the usual mathematical operators (+, -, *, /, etc.) are supported.\nExamples Below are several example expressions:\nA * B + C * D (X + Y) * Z X + (Y * Z) 40 + 3.14 Interactive examples:\n\u0026gt;\u0026gt;\u0026gt; int(3.1415) 6 \u0026gt;\u0026gt;\u0026gt; float(3) 3.0 \u0026gt;\u0026gt;\u0026gt; a = 3 \u0026gt;\u0026gt;\u0026gt; b = 4 \u0026gt;\u0026gt;\u0026gt; a + 1, a - 1 (4, 2) \u0026gt;\u0026gt;\u0026gt; b * 3, b / 2 # (Results depend on the expression) \u0026gt;\u0026gt;\u0026gt; a % 2, b ** 2 # (Results depend on the expression) \u0026gt;\u0026gt;\u0026gt; 2 + 4.0, 2.0 ** b # (Results depend on the expression) \u0026gt;\u0026gt;\u0026gt; b / (2.0 + a) 0.80000000000000004 \u0026gt;\u0026gt;\u0026gt; print(b / (2.0 + a)) 0.8 \u0026gt;\u0026gt;\u0026gt; 1 / 2.0 0.5 \u0026gt;\u0026gt;\u0026gt; num = 1 / 3.0 \u0026gt;\u0026gt;\u0026gt; num 0.33333333333333331 \u0026gt;\u0026gt;\u0026gt; print(num) 0.333333333333 \u0026gt;\u0026gt;\u0026gt; \u0026#39;%e\u0026#39; % num \u0026#39;3.333333e-01\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;%4.2f\u0026#39; % num \u0026#39;0.33\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;{0:4.2f}\u0026#39;.format(num) \u0026#39;0.33\u0026#39; The comments above explain:\nConverting a float to an integer and vice versa. Basic arithmetic operations such as addition, subtraction, multiplication, division, modulus, and exponentiation. Mixed-type conversions and string formatting for floating-point numbers. Comparisons: Normal and Chained Numbers can also be compared. Normal comparisons compare the relative magnitudes of their operands and return a Boolean result:\n\u0026gt;\u0026gt;\u0026gt; 1 \u0026lt; 2 True \u0026gt;\u0026gt;\u0026gt; 2.0 \u0026gt;= 1 True \u0026gt;\u0026gt;\u0026gt; 2.0 == 2.0 True \u0026gt;\u0026gt;\u0026gt; 2.0 != 2.0 False Python also supports chained comparisons, which allow range tests:\n\u0026gt;\u0026gt;\u0026gt; Y = 4 \u0026gt;\u0026gt;\u0026gt; Z = 6 \u0026gt;\u0026gt;\u0026gt; X \u0026lt; Y \u0026lt; Z # Equivalent to: X \u0026lt; Y and Y \u0026lt; Z True \u0026gt;\u0026gt;\u0026gt; X \u0026lt; Y and Y \u0026lt; Z True \u0026gt;\u0026gt;\u0026gt; X \u0026lt; Y \u0026gt; Z # Chained comparisons with a false result False \u0026gt;\u0026gt;\u0026gt; 1 \u0026lt; 2 \u0026lt; 3.0 \u0026lt; 4 True \u0026gt;\u0026gt;\u0026gt; 1 \u0026gt; 2 \u0026gt; 3.0 \u0026gt; 4 False \u0026gt;\u0026gt;\u0026gt; 1 == 2 \u0026lt; 3 False Division and Floor Division The division operators behave differently depending on the operands:\nC:\\misc\u0026gt; C:\\Python30\\python \u0026gt;\u0026gt;\u0026gt; 10 / 4 # True division (Python 3.0) 2.5 \u0026gt;\u0026gt;\u0026gt; 10 // 4 # Floor division: truncates the remainder 2 \u0026gt;\u0026gt;\u0026gt; 10 / 4.0 2.5 \u0026gt;\u0026gt;\u0026gt; 10 // 4.0 # Floor division with float result 2.0 C:\\misc\u0026gt; C:\\Python26\\python \u0026gt;\u0026gt;\u0026gt; 10 / 4 2 \u0026gt;\u0026gt;\u0026gt; 10 // 4 2 \u0026gt;\u0026gt;\u0026gt; 10 / 4.0 2.5 \u0026gt;\u0026gt;\u0026gt; 10 // 4.0 2.0 Complex Numbers Complex numbers are represented as two floating-point numbers (the real and imaginary parts). The imaginary part is denoted by a j or J suffix.\n\u0026gt;\u0026gt;\u0026gt; 1j * 1J (-1+0j) \u0026gt;\u0026gt;\u0026gt; 2 + 1j * 3 (2+3j) \u0026gt;\u0026gt;\u0026gt; (2 + 1j) * 3 (6+3j) Hexadecimal, Octal, and Binary Notation Python integers can be written in hexadecimal, octal, and binary notations:\n\u0026gt;\u0026gt;\u0026gt; 0o1, 0o20, 0o377 (1, 16, 255) \u0026gt;\u0026gt;\u0026gt; 0x01, 0x10, 0xFF (1, 16, 255) \u0026gt;\u0026gt;\u0026gt; 0b1, 0b10000, 0b11111111 (1, 16, 255) Conversion functions:\n\u0026gt;\u0026gt;\u0026gt; oct(64), hex(64), bin(64) (\u0026#39;0100\u0026#39;, \u0026#39;0x40\u0026#39;, \u0026#39;0b1000000\u0026#39;) \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;64\u0026#39;), int(\u0026#39;100\u0026#39;, 8), int(\u0026#39;40\u0026#39;, 16), int(\u0026#39;1000000\u0026#39;, 2) (64, 64, 64, 64) \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;0x40\u0026#39;, 16), int(\u0026#39;0b1000000\u0026#39;, 2) (64, 64) Using eval to process literals:\n\u0026gt;\u0026gt;\u0026gt; eval(\u0026#39;64\u0026#39;), eval(\u0026#39;0o100\u0026#39;), eval(\u0026#39;0x40\u0026#39;), eval(\u0026#39;0b1000000\u0026#39;) (64, 64, 64, 64) String formatting for other bases:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;{0:o}, {1:x}, {2:b}\u0026#39;.format(64, 64, 64) \u0026#39;100, 40, 1000000\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;%o, %x, %X\u0026#39; % (64, 255, 255) \u0026#39;100, ff, FF\u0026#39; Bitwise Operations Python supports bitwise operations on integers. For example:\n\u0026gt;\u0026gt;\u0026gt; x = 1 # Binary: 0001 \u0026gt;\u0026gt;\u0026gt; x \u0026lt;\u0026lt; 2 # Shift left 2 bits: 0100 4 \u0026gt;\u0026gt;\u0026gt; x | 2 # Bitwise OR: 0001 | 0010 = 0011 3 \u0026gt;\u0026gt;\u0026gt; x \u0026amp; 1 # Bitwise AND: 0001 \u0026amp; 0001 = 0001 1 Additional bitwise examples:\n\u0026gt;\u0026gt;\u0026gt; X = 0b0001 \u0026gt;\u0026gt;\u0026gt; X \u0026lt;\u0026lt; 2 4 \u0026gt;\u0026gt;\u0026gt; bin(X \u0026lt;\u0026lt; 2) \u0026#39;0b100\u0026#39; \u0026gt;\u0026gt;\u0026gt; bin(X | 0b010) \u0026#39;0b11\u0026#39; \u0026gt;\u0026gt;\u0026gt; bin(X \u0026amp; 0b1) \u0026#39;0b1\u0026#39; Hexadecimal and XOR examples:\n\u0026gt;\u0026gt;\u0026gt; X = 0xFF \u0026gt;\u0026gt;\u0026gt; bin(X) \u0026#39;0b11111111\u0026#39; \u0026gt;\u0026gt;\u0026gt; X ^ 0b10101010 85 \u0026gt;\u0026gt;\u0026gt; bin(X ^ 0b10101010) \u0026#39;0b1010101\u0026#39; \u0026gt;\u0026gt;\u0026gt; int(\u0026#39;1010101\u0026#39;, 2) 85 \u0026gt;\u0026gt;\u0026gt; hex(85) \u0026#39;0x55\u0026#39; Other Built-in Numeric Tools Python provides many built-in functions and standard library modules for numeric processing:\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; math.pi, math.e (3.1415926535897931, 2.7182818284590451) \u0026gt;\u0026gt;\u0026gt; math.sin(2 * math.pi / 180) 0.034899496702500969 \u0026gt;\u0026gt;\u0026gt; math.sqrt(144), math.sqrt(2) (12.0, 1.4142135623730951) \u0026gt;\u0026gt;\u0026gt; pow(2, 4), 2 ** 4 (16, 16) \u0026gt;\u0026gt;\u0026gt; abs(-42.0), sum((1, 2, 3, 4)) (42.0, 10) \u0026gt;\u0026gt;\u0026gt; min(3, 1, 2, 4), max(3, 1, 2, 4) (1, 4) Rounding and Formatting Truncation and rounding examples:\n\u0026gt;\u0026gt;\u0026gt; math.floor(2.567), math.floor(-2.567) (2, -3) \u0026gt;\u0026gt;\u0026gt; math.trunc(2.567), math.trunc(-2.567) (2, -2) \u0026gt;\u0026gt;\u0026gt; int(2.567), int(-2.567) (2, -2) \u0026gt;\u0026gt;\u0026gt; round(2.567), round(2.467), round(2.567, 2) (3, 2, 2.57) \u0026gt;\u0026gt;\u0026gt; \u0026#39;%.1f\u0026#39; % 2.567, \u0026#39;{0:.2f}\u0026#39;.format(2.567) (\u0026#39;2.6\u0026#39;, \u0026#39;2.57\u0026#39;) Note the difference between round (which returns a number) and string formatting (which produces a string):\n\u0026gt;\u0026gt;\u0026gt; (1 / 3), round(1 / 3, 2), (\u0026#39;%.2f\u0026#39; % (1 / 3)) (0.33333333333333331, 0.33, \u0026#39;0.33\u0026#39;) Square Roots There are three common ways to compute square roots:\n\u0026gt;\u0026gt;\u0026gt; import math \u0026gt;\u0026gt;\u0026gt; math.sqrt(144) 12.0 \u0026gt;\u0026gt;\u0026gt; 144 ** 0.5 12.0 \u0026gt;\u0026gt;\u0026gt; pow(144, 0.5) 12.0 \u0026gt;\u0026gt;\u0026gt; math.sqrt(1234567890) 35136.418286444619 \u0026gt;\u0026gt;\u0026gt; 1234567890 ** 0.5 35136.418286444619 \u0026gt;\u0026gt;\u0026gt; pow(1234567890, 0.5) 35136.418286444619 The Random Module The standard library random module provides tools for generating random numbers:\n\u0026gt;\u0026gt;\u0026gt; import random \u0026gt;\u0026gt;\u0026gt; random.random() 0.44694718823781876 \u0026gt;\u0026gt;\u0026gt; random.random() 0.28970426439292829 \u0026gt;\u0026gt;\u0026gt; random.randint(1, 10) 5 \u0026gt;\u0026gt;\u0026gt; random.randint(1, 10) 4 \u0026gt;\u0026gt;\u0026gt; random.choice([\u0026#39;Life of Brian\u0026#39;, \u0026#39;Holy Grail\u0026#39;, \u0026#39;Meaning of Life\u0026#39;]) \u0026#39;Life of Brian\u0026#39; \u0026gt;\u0026gt;\u0026gt; random.choice([\u0026#39;Life of Brian\u0026#39;, \u0026#39;Holy Grail\u0026#39;, \u0026#39;Meaning of Life\u0026#39;]) \u0026#39;Holy Grail\u0026#39; The random module can be useful for shuffling items, selecting random elements, performing simulations, and more.\nChapter Summary Numeric Types Overview:\nPython supports a wide range of numeric types including integers, floats, complex numbers, decimals, fractions, and more.\nLiterals and Operators:\nNumeric literals can be written in decimal, hexadecimal, octal, and binary formats. Operators and built-in functions (e.g., pow, abs, round) allow for a variety of arithmetic and bitwise operations.\nComparisons and Chaining:\nNumbers can be compared normally or with chained comparisons to perform range tests.\nComplex and Special Numbers:\nPython supports complex numbers and provides various modules (like math and random) for advanced numeric processing.\nUtility Tools:\nBuilt-in functions and modules offer additional tools for numeric conversion, formatting, rounding, and generating random numbers.\n","permalink":"/chapters/chapter-5/","summary":"\u003cp\u003eLet’s get started by exploring our first data type category: Python’s numeric types.\u003c/p\u003e\n\u003ch2 id=\"numeric-type-basics\"\u003eNumeric Type Basics\u003c/h2\u003e\n\u003cp\u003eA complete inventory of Python’s numeric toolbox includes:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003eIntegers and floating-point numbers\u003c/li\u003e\n\u003cli\u003eComplex numbers\u003c/li\u003e\n\u003cli\u003eFixed-precision decimal numbers\u003c/li\u003e\n\u003cli\u003eRational fraction numbers\u003c/li\u003e\n\u003cli\u003eSets\u003c/li\u003e\n\u003cli\u003eBooleans\u003c/li\u003e\n\u003cli\u003eUnlimited integer precision\u003c/li\u003e\n\u003cli\u003eA variety of numeric built-ins and modules\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eWe will present a brief overview of how we write and process numbers in our scripts.\u003c/p\u003e\n\u003ch2 id=\"numeric-literals\"\u003eNumeric Literals\u003c/h2\u003e\n\u003cp\u003eAmong its basic types, Python provides integers (positive and negative whole numbers) and floating-point numbers (numbers with a fractional part, sometimes called \u0026ldquo;floats\u0026rdquo; for economy). Table 1 (not shown) illustrates what Python’s numeric types look like when written as literals.\u003c/p\u003e","title":"Chapter 5: Numeric Types"},{"content":" String Literals There are many ways to write strings in your code:\nSingle quotes: 'spa\u0026quot;m' Double quotes: \u0026quot;spa'm\u0026quot; Triple quotes: '''... spam ...''' or \u0026quot;\u0026quot;\u0026quot;... spam ...\u0026quot;\u0026quot;\u0026quot; Escape sequences: \u0026quot;s\\tp\\na\\0m\u0026quot; Raw strings: r\u0026quot;C:\\new\\test.spm\u0026quot; The single- and double-quoted forms are by far the most common.\nSingle- and Double-Quoted Strings Are the Same Around Python strings, single and double quote characters are interchangeable. That is, string literals can be written enclosed in either single or double quotes; the two forms work the same and return the same type of object.\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;shrubbery\u0026#39;, \u0026#34;shrubbery\u0026#34; (\u0026#39;shrubbery\u0026#39;, \u0026#39;shrubbery\u0026#39;) They allow you to embed a quote character of the other variety without escaping it:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;knight\u0026#34;s\u0026#39;, \u0026#34;knight\u0026#39;s\u0026#34; (\u0026#39;knight\u0026#34;s\u0026#39;, \u0026#34;knight\u0026#39;s\u0026#34;) Python automatically concatenates adjacent string literals:\n\u0026gt;\u0026gt;\u0026gt; title = \u0026#34;Meaning \u0026#34; \u0026#39;of\u0026#39; \u0026#34; Life\u0026#34; \u0026gt;\u0026gt;\u0026gt; title \u0026#39;Meaning of Life\u0026#39; Escape Sequences Represent Special Bytes Backslashes are used to introduce escape sequences which represent special byte values. For example:\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#39;a\\nb\\tc\u0026#39; \u0026gt;\u0026gt;\u0026gt; s \u0026#39;a\\nb\\tc\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(s) a b\tc \u0026gt;\u0026gt;\u0026gt; len(s) 5 Another example with binary zero bytes:\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#39;a\\0b\\0c\u0026#39; \u0026gt;\u0026gt;\u0026gt; s \u0026#39;a\\x00b\\x00c\u0026#39; \u0026gt;\u0026gt;\u0026gt; len(s) 5 And a string with absolute binary escape codes:\n\u0026gt;\u0026gt;\u0026gt; s = \u0026#39;\\001\\002\\x03\u0026#39; \u0026gt;\u0026gt;\u0026gt; s \u0026#39;\\x01\\x02\\x03\u0026#39; \u0026gt;\u0026gt;\u0026gt; len(s) 3 Basic Operations on Strings Strings can be concatenated using the + operator and repeated using the * operator:\n\u0026gt;\u0026gt;\u0026gt; len(\u0026#39;abc\u0026#39;) 3 \u0026gt;\u0026gt;\u0026gt; \u0026#39;abc\u0026#39; + \u0026#39;def\u0026#39; \u0026#39;abcdef\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;Ni!\u0026#39; * 4 \u0026#39;Ni!Ni!Ni!Ni!\u0026#39; Adding two string objects creates a new string, while repetition concatenates a string to itself multiple times.\nString Methods Methods are functions attached to string objects that perform higher-level operations. For example, some common string methods include:\nS.capitalize() S.ljust(width [, fill]) S.center(width [, fill]) S.lower() S.count(sub [, start [, end]]) S.lstrip([chars]) S.encode([encoding [,errors]]) S.maketrans(x[, y[, z]]) S.endswith(suffix [, start [, end]]) S.partition(sep) S.expandtabs([tabsize]) S.replace(old, new [, count]) S.find(sub [, start [, end]]) S.rfind(sub [, start [, end]]) S.format(fmtstr, *args, **kwargs) S.rindex(sub [, start [, end]]) S.index(sub [, start [, end]]) S.rjust(width [, fill]) S.isalnum() S.rpartition(sep) S.isalpha() S.rsplit([sep[, maxsplit]]) S.isdecimal() S.rstrip([chars]) S.isdigit() S.split([sep [,maxsplit]]) S.isidentifier() S.splitlines([keepends]) S.islower() S.startswith(prefix [, start [, end]]) S.isnumeric() S.strip([chars]) S.isprintable() S.swapcase() S.isspace() S.title() S.istitle() S.translate(map) S.isupper() S.upper() S.join(iterable) S.zfill(width) String Method Examples: Changing Strings Since strings are immutable, you must create a new string when making changes.\nUsing slicing and concatenation:\n\u0026gt;\u0026gt;\u0026gt; S = \u0026#39;spammy\u0026#39; \u0026gt;\u0026gt;\u0026gt; S = S[:3] + \u0026#39;xx\u0026#39; + S[5:] \u0026gt;\u0026gt;\u0026gt; S \u0026#39;spaxxy\u0026#39; Using the replace method:\n\u0026gt;\u0026gt;\u0026gt; S = \u0026#39;spammy\u0026#39; \u0026gt;\u0026gt;\u0026gt; S = S.replace(\u0026#39;mm\u0026#39;, \u0026#39;xx\u0026#39;) \u0026gt;\u0026gt;\u0026gt; S \u0026#39;spaxxy\u0026#39; Global replacement example:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;aa$bb$cc$dd\u0026#39;.replace(\u0026#39;$\u0026#39;, \u0026#39;SPAM\u0026#39;) \u0026#39;aaSPAMbbSPAMccSPAMdd\u0026#39; To modify a string in-place, convert it to a list, modify, then join back:\n\u0026gt;\u0026gt;\u0026gt; S = \u0026#39;spammy\u0026#39; \u0026gt;\u0026gt;\u0026gt; L = list(S) \u0026gt;\u0026gt;\u0026gt; L [\u0026#39;s\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;m\u0026#39;, \u0026#39;y\u0026#39;] \u0026gt;\u0026gt;\u0026gt; L[3] = \u0026#39;x\u0026#39; \u0026gt;\u0026gt;\u0026gt; L[4] = \u0026#39;x\u0026#39; \u0026gt;\u0026gt;\u0026gt; L [\u0026#39;s\u0026#39;, \u0026#39;p\u0026#39;, \u0026#39;a\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;x\u0026#39;, \u0026#39;y\u0026#39;] \u0026gt;\u0026gt;\u0026gt; S = \u0026#39;\u0026#39;.join(L) \u0026gt;\u0026gt;\u0026gt; S \u0026#39;spaxxy\u0026#39; Joining Strings The join method concatenates an iterable of strings with a delimiter:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;SPAM\u0026#39;.join([\u0026#39;eggs\u0026#39;, \u0026#39;sausage\u0026#39;, \u0026#39;ham\u0026#39;, \u0026#39;toast\u0026#39;]) \u0026#39;eggsSPAMsausageSPAMhamSPAMtoast\u0026#39; Slicing and Splitting Strings Slicing extracts fixed substrings:\n\u0026gt;\u0026gt;\u0026gt; line = \u0026#39;aaa bbb ccc\u0026#39; \u0026gt;\u0026gt;\u0026gt; col1 = line[0:3] \u0026gt;\u0026gt;\u0026gt; col3 = line[8:] \u0026gt;\u0026gt;\u0026gt; col1 \u0026#39;aaa\u0026#39; \u0026gt;\u0026gt;\u0026gt; col3 \u0026#39;ccc\u0026#39; Splitting divides a string into substrings based on a delimiter (whitespace by default):\n\u0026gt;\u0026gt;\u0026gt; line = \u0026#39;aaa bbb ccc\u0026#39; \u0026gt;\u0026gt;\u0026gt; cols = line.split() \u0026gt;\u0026gt;\u0026gt; cols [\u0026#39;aaa\u0026#39;, \u0026#39;bbb\u0026#39;, \u0026#39;ccc\u0026#39;] For other delimiters, pass the delimiter to split().\nOther Common String Methods in Action Examples of other string methods:\n\u0026gt;\u0026gt;\u0026gt; line = \u0026#34;The knights who say Ni!\\n\u0026#34; \u0026gt;\u0026gt;\u0026gt; line.rstrip() \u0026#39;The knights who say Ni!\u0026#39; \u0026gt;\u0026gt;\u0026gt; line.upper() \u0026#39;THE KNIGHTS WHO SAY NI!\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; line.isalpha() False \u0026gt;\u0026gt;\u0026gt; line.endswith(\u0026#39;Ni!\\n\u0026#39;) True \u0026gt;\u0026gt;\u0026gt; line.startswith(\u0026#39;The\u0026#39;) True Alternative techniques:\n\u0026gt;\u0026gt;\u0026gt; line \u0026#39;The knights who say Ni!\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; line.find(\u0026#39;Ni\u0026#39;) != -1 True \u0026gt;\u0026gt;\u0026gt; \u0026#39;Ni\u0026#39; in line True \u0026gt;\u0026gt;\u0026gt; sub = \u0026#39;Ni!\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; line.endswith(sub) True \u0026gt;\u0026gt;\u0026gt; line[-len(sub):] == sub True String Formatting Expressions String formatting allows multiple type-specific substitutions in a single step. The original technique uses the % operator:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;That is %d %s bird!\u0026#39; % (1, \u0026#39;dead\u0026#39;) \u0026#39;That is 1 dead bird!\u0026#39; More examples:\n\u0026gt;\u0026gt;\u0026gt; exclamation = \u0026#34;Ni\u0026#34; \u0026gt;\u0026gt;\u0026gt; \u0026#34;The knights who say %s!\u0026#34; % exclamation \u0026#39;The knights who say Ni!\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#34;%d %s %d you\u0026#34; % (1, \u0026#39;spam\u0026#39;, 4) \u0026#39;1 spam 4 you\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#34;%s -- %s -- %s\u0026#34; % (42, 3.14159, [1, 2, 3]) \u0026#39;42 -- 3.14159 -- [1, 2, 3]\u0026#39; Advanced String Formatting Expressions Conversion type codes can be used in formatting expressions. The general structure is:\n%[(name)][flags][width][.precision]typecode Below is a table of common type codes:\nCode Meaning s String (or any object\u0026rsquo;s str() string) r Same as s, but uses repr() instead c Character d Decimal (integer) i Integer u Same as d (obsolete) o Octal integer x Hex integer X Hex integer (uppercase) e Floating-point exponent, lowercase E Floating-point exponent, uppercase f Floating-point decimal F Floating-point decimal g Floating-point (uses e or f, whichever is shorter) G Floating-point (uses E or F, whichever is shorter) % Literal % Examples:\n\u0026gt;\u0026gt;\u0026gt; x = 1234 \u0026gt;\u0026gt;\u0026gt; res = \u0026#34;integers: ...%d...%-6d...%06d\u0026#34; % (x, x, x) \u0026gt;\u0026gt;\u0026gt; res \u0026#39;integers: ...1234...1234 ...001234\u0026#39; Floating-point formatting:\n\u0026gt;\u0026gt;\u0026gt; x = 1.23456789 \u0026gt;\u0026gt;\u0026gt; x 1.2345678899999999 \u0026gt;\u0026gt;\u0026gt; \u0026#39;%e | %f | %g\u0026#39; % (x, x, x) \u0026#39;1.234568e+00 | 1.234568 | 1.23457\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#39;%E\u0026#39; % x \u0026#39;1.234568E+00\u0026#39; More formatting examples:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;%-6.2f | %05.2f | %+06.1f\u0026#39; % (x, x, x) \u0026#39;1.23 | 01.23 | +001.2\u0026#39; \u0026gt;\u0026gt;\u0026gt; \u0026#34;%s\u0026#34; % x, str(x) (\u0026#39;1.23456789\u0026#39;, \u0026#39;1.23456789\u0026#39;) Dynamic width and precision:\n\u0026gt;\u0026gt;\u0026gt; \u0026#39;%f, %.2f, %.*f\u0026#39; % (1/3.0, 1/3.0, 4, 1/3.0) \u0026#39;0.333333, 0.33, 0.3333\u0026#39; Examples (Strings) Find the length of a word: len(word) Convert a string to upper case: word.upper() Capitalize the first word (first letter uppercase, rest lowercase): print(word.capitalize()) Convert a string to lower case: word.lower() Concatenate first name and surname without a space: name = firstname + surname Convert a phrase to title case: word.title() Remove extra spaces from the start and end of a string: text = \u0026#34; This is some text. \u0026#34; print(text.strip(\u0026#34; \u0026#34;)) Slice a string: print(\u0026#34;Hello world\u0026#34;[7:10]) (This displays \u0026ldquo;orl\u0026rdquo; from \u0026ldquo;Hello world\u0026rdquo; where indexing starts at 0.) Prompt the user for their first name and display its length. Prompt for first name and surname, join them with a space, and display the full name and its length. Prompt for first name and surname in lower case, convert to title case, join them, and display the result. Prompt for the first line of a nursery rhyme, display its length, then ask for a starting and ending number and display that substring. Prompt the user to enter any word and display it in upper case. Prompt for the user\u0026rsquo;s first name. If its length is under five characters, ask for their surname, join them without a space, and display the result in upper case; otherwise, display the first name in lower case. Pig Latin Conversion: If a word begins with a consonant, move the first consonant to the end and add \u0026ldquo;ay\u0026rdquo;. If a word begins with a vowel, add \u0026ldquo;way\u0026rdquo; to the end.\nDisplay the resulting word in lower case. Chapter Summary String Literals:\nVarious ways to define strings include single, double, and triple quotes, along with escape sequences and raw strings.\nEscape Sequences:\nSpecial sequences using backslashes allow embedding non-printable or special characters in strings.\nBasic Operations:\nStrings support concatenation with +, repetition with *, slicing, and length determination using len().\nString Methods:\nBuilt-in methods offer operations such as case conversion, searching, splitting, joining, and replacing substrings.\nString Formatting:\nBoth old-style (%) formatting and advanced formatting expressions provide flexible ways to format strings.\nPractical Examples:\nNumerous examples illustrate how to manipulate and format strings, perform substring operations, and convert between mutable and immutable types.\n","permalink":"/chapters/chapter-6/","summary":"\u003chr\u003e\n\u003ch2 id=\"string-literals\"\u003eString Literals\u003c/h2\u003e\n\u003cp\u003eThere are many ways to write strings in your code:\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e\u003cstrong\u003eSingle quotes:\u003c/strong\u003e \u003ccode\u003e'spa\u0026quot;m'\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eDouble quotes:\u003c/strong\u003e \u003ccode\u003e\u0026quot;spa'm\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eTriple quotes:\u003c/strong\u003e \u003ccode\u003e'''... spam ...'''\u003c/code\u003e or \u003ccode\u003e\u0026quot;\u0026quot;\u0026quot;... spam ...\u0026quot;\u0026quot;\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eEscape sequences:\u003c/strong\u003e \u003ccode\u003e\u0026quot;s\\tp\\na\\0m\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\u003cli\u003e\u003cstrong\u003eRaw strings:\u003c/strong\u003e \u003ccode\u003er\u0026quot;C:\\new\\test.spm\u0026quot;\u003c/code\u003e\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003eThe single- and double-quoted forms are by far the most common.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"single--and-double-quoted-strings-are-the-same\"\u003eSingle- and Double-Quoted Strings Are the Same\u003c/h2\u003e\n\u003cp\u003eAround Python strings, single and double quote characters are interchangeable. That is, string literals can be written enclosed in either single or double quotes; the two forms work the same and return the same type of object.\u003c/p\u003e","title":"Chapter 6: Strings"},{"content":"The list and dictionary object types are the main workhorses in almost all Python scripts. They are used to store, organize, and retrieve data efficiently. In this chapter, we cover how lists and dictionaries work, their basic operations, and how to modify them in-place.\nLists Lists are ordered collections of arbitrary objects. Unlike strings, lists can contain any type of object—including numbers, strings, and even other lists. Lists are mutable, meaning you can change their contents in-place using assignment (to individual items or slices), method calls, deletion statements, and more. Key properties include:\nOrdered collections of arbitrary objects Accessed by offset (index) Variable-length, heterogeneous, and arbitrarily nestable Belong to the category “mutable sequence” Arrays of object references Common List Literals and Operations Below is a placeholder for a table summarizing common list literals and operations:\nOperation Description Example [] Empty list literal [] [item1, ...] List literal with items [1, 2, 3] L + M Concatenation of two lists [1, 2] + [3, 4] ['Ni!'] * 4 Repetition of a list element ['Ni!', 'Ni!', 'Ni!', 'Ni!'] Basic List Operations Lists support many of the same operations as strings. For example:\n\u0026gt;\u0026gt;\u0026gt; len([1, 2, 3]) 3 \u0026gt;\u0026gt;\u0026gt; [1, 2, 3] + [4, 5, 6] [1, 2, 3, 4, 5, 6] \u0026gt;\u0026gt;\u0026gt; [\u0026#39;Ni!\u0026#39;] * 4 [\u0026#39;Ni!\u0026#39;, \u0026#39;Ni!\u0026#39;, \u0026#39;Ni!\u0026#39;, \u0026#39;Ni!\u0026#39;] Note: The + operator for lists requires both operands to be sequences. To combine a list and a string, you must convert one of them:\n\u0026gt;\u0026gt;\u0026gt; str([1, 2]) + \u0026#34;34\u0026#34; \u0026#39;[1, 2]34\u0026#39; \u0026gt;\u0026gt;\u0026gt; [1, 2] + list(\u0026#34;34\u0026#34;) [1, 2, \u0026#39;3\u0026#39;, \u0026#39;4\u0026#39;] List Iteration and Comprehensions Lists support membership tests and iteration:\n\u0026gt;\u0026gt;\u0026gt; 3 in [1, 2, 3] True \u0026gt;\u0026gt;\u0026gt; for x in [1, 2, 3]: ... print(x, end=\u0026#39; \u0026#39;) 1 2 3 List comprehensions offer a concise way to build new lists:\n\u0026gt;\u0026gt;\u0026gt; res = [c * 4 for c in \u0026#39;SPAM\u0026#39;] \u0026gt;\u0026gt;\u0026gt; res [\u0026#39;SSSS\u0026#39;, \u0026#39;PPPP\u0026#39;, \u0026#39;AAAA\u0026#39;, \u0026#39;MMMM\u0026#39;] This is equivalent to:\n\u0026gt;\u0026gt;\u0026gt; res = [] \u0026gt;\u0026gt;\u0026gt; for c in \u0026#39;SPAM\u0026#39;: ... res.append(c * 4) \u0026gt;\u0026gt;\u0026gt; res [\u0026#39;SSSS\u0026#39;, \u0026#39;PPPP\u0026#39;, \u0026#39;AAAA\u0026#39;, \u0026#39;MMMM\u0026#39;] Indexing, Slicing, and Matrixes Since lists are sequences, you can index and slice them just like strings. However, indexing a list returns the object at that position, while slicing always returns a new list.\n\u0026gt;\u0026gt;\u0026gt; L = [\u0026#39;spam\u0026#39;, \u0026#39;Spam\u0026#39;, \u0026#39;SPAM!\u0026#39;] \u0026gt;\u0026gt;\u0026gt; L[2] \u0026#39;SPAM!\u0026#39; \u0026gt;\u0026gt;\u0026gt; L[-2] \u0026#39;Spam\u0026#39; \u0026gt;\u0026gt;\u0026gt; L[1:] [\u0026#39;Spam\u0026#39;, \u0026#39;SPAM!\u0026#39;] Lists can be nested. For example, a simple 3×3 matrix can be represented as:\n\u0026gt;\u0026gt;\u0026gt; matrix = [[1, 2, 3], [4, 5, 6], [7, 8, 9]] \u0026gt;\u0026gt;\u0026gt; matrix[1] # Get the second row [4, 5, 6] \u0026gt;\u0026gt;\u0026gt; matrix[1][1] # Get the middle element 5 Changing Lists In-Place Because lists are mutable, you can modify them by assigning new values to individual items or slices:\n\u0026gt;\u0026gt;\u0026gt; L = [\u0026#39;spam\u0026#39;, \u0026#39;Spam\u0026#39;, \u0026#39;SPAM!\u0026#39;] \u0026gt;\u0026gt;\u0026gt; L[1] = \u0026#39;eggs\u0026#39; \u0026gt;\u0026gt;\u0026gt; L [\u0026#39;spam\u0026#39;, \u0026#39;eggs\u0026#39;, \u0026#39;SPAM!\u0026#39;] \u0026gt;\u0026gt;\u0026gt; L[0:2] = [\u0026#39;eat\u0026#39;, \u0026#39;more\u0026#39;] \u0026gt;\u0026gt;\u0026gt; L [\u0026#39;eat\u0026#39;, \u0026#39;more\u0026#39;, \u0026#39;SPAM!\u0026#39;] Slice assignment works in two steps:\nThe specified slice is deleted. New items are inserted in its place. For example, given L = [1, 2, 3], the assignment L[1:2] = [4, 5] results in [1, 4, 5, 3].\nList Method Calls List objects provide many methods that modify the list in-place. Some common methods include:\nappend(): Add an element to the end. extend(): Add multiple elements. pop(): Remove and return an element (default is the last item). insert(): Insert an element at a specified index. remove(): Remove the first occurrence of a value. sort(): Sort the list in-place. reverse(): Reverse the list in-place. reversed(): Returns an iterator that yields the list in reverse order. Examples:\n\u0026gt;\u0026gt;\u0026gt; L = [\u0026#39;spam\u0026#39;, \u0026#39;eggs\u0026#39;, \u0026#39;ham\u0026#39;] \u0026gt;\u0026gt;\u0026gt; L.append(\u0026#39;please\u0026#39;) \u0026gt;\u0026gt;\u0026gt; L [\u0026#39;spam\u0026#39;, \u0026#39;eggs\u0026#39;, \u0026#39;ham\u0026#39;, \u0026#39;please\u0026#39;] \u0026gt;\u0026gt;\u0026gt; L.sort() \u0026gt;\u0026gt;\u0026gt; L [\u0026#39;SPAM!\u0026#39;, \u0026#39;eat\u0026#39;, \u0026#39;more\u0026#39;, \u0026#39;please\u0026#39;] # Example output after sort \u0026gt;\u0026gt;\u0026gt; L.extend([1, 2, 3]) \u0026gt;\u0026gt;\u0026gt; L [\u0026#39;spam\u0026#39;, \u0026#39;eggs\u0026#39;, \u0026#39;ham\u0026#39;, \u0026#39;please\u0026#39;, 1, 2, 3] \u0026gt;\u0026gt;\u0026gt; L.pop() 3 \u0026gt;\u0026gt;\u0026gt; L [\u0026#39;spam\u0026#39;, \u0026#39;eggs\u0026#39;, \u0026#39;ham\u0026#39;, \u0026#39;please\u0026#39;] For stack-like behavior:\n\u0026gt;\u0026gt;\u0026gt; stack = [] \u0026gt;\u0026gt;\u0026gt; stack.append(1) \u0026gt;\u0026gt;\u0026gt; stack.append(2) \u0026gt;\u0026gt;\u0026gt; stack.pop() 2 To reverse a list without modifying it, use the reversed built-in wrapped in list():\n\u0026gt;\u0026gt;\u0026gt; list(reversed(L)) Dictionaries Dictionaries are mutable mappings that store key–value pairs. Unlike lists, they are unordered and are accessed by key rather than by numerical index. Dictionaries are implemented as hash tables, which means that lookups are very fast.\nCommon Dictionary Literals and Operations Below is a placeholder for a table summarizing common dictionary literals and operations:\nOperation Description Example {} Empty dictionary literal {} {'key': value} Dictionary literal with a key–value pair {'a': 1, 'b': 2} D[key] Access value by key D['spam'] D[key] = value Set or update value for a key D['eggs'] = 3 del D[key] Delete a key–value pair del D['ham'] Basic Dictionary Operations Dictionaries are created using curly braces with key–value pairs:\n\u0026gt;\u0026gt;\u0026gt; D = {\u0026#39;spam\u0026#39;: 2, \u0026#39;ham\u0026#39;: 1, \u0026#39;eggs\u0026#39;: 3} \u0026gt;\u0026gt;\u0026gt; D[\u0026#39;spam\u0026#39;] 2 \u0026gt;\u0026gt;\u0026gt; len(D) 3 \u0026gt;\u0026gt;\u0026gt; \u0026#39;ham\u0026#39; in D True \u0026gt;\u0026gt;\u0026gt; list(D.keys()) [\u0026#39;eggs\u0026#39;, \u0026#39;ham\u0026#39;, \u0026#39;spam\u0026#39;] Note: The order of keys is not guaranteed. If you need a specific order, you can sort the keys.\nChanging Dictionaries In-Place Since dictionaries are mutable, you can change their contents by assigning to keys or using the del statement:\n\u0026gt;\u0026gt;\u0026gt; D = {\u0026#39;eggs\u0026#39;: 3, \u0026#39;ham\u0026#39;: 1, \u0026#39;spam\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt; D[\u0026#39;ham\u0026#39;] = [\u0026#39;grill\u0026#39;, \u0026#39;bake\u0026#39;, \u0026#39;fry\u0026#39;] \u0026gt;\u0026gt;\u0026gt; D {\u0026#39;eggs\u0026#39;: 3, \u0026#39;ham\u0026#39;: [\u0026#39;grill\u0026#39;, \u0026#39;bake\u0026#39;, \u0026#39;fry\u0026#39;], \u0026#39;spam\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt; del D[\u0026#39;eggs\u0026#39;] \u0026gt;\u0026gt;\u0026gt; D {\u0026#39;ham\u0026#39;: [\u0026#39;grill\u0026#39;, \u0026#39;bake\u0026#39;, \u0026#39;fry\u0026#39;], \u0026#39;spam\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt; D[\u0026#39;brunch\u0026#39;] = \u0026#39;Bacon\u0026#39; \u0026gt;\u0026gt;\u0026gt; D {\u0026#39;ham\u0026#39;: [\u0026#39;grill\u0026#39;, \u0026#39;bake\u0026#39;, \u0026#39;fry\u0026#39;], \u0026#39;spam\u0026#39;: 2, \u0026#39;brunch\u0026#39;: \u0026#39;Bacon\u0026#39;} Using Dictionaries to Simulate Flexible Lists Unlike lists, dictionaries do not require pre-allocation of space. For example, you can assign a value to a key without needing every index to exist:\n\u0026gt;\u0026gt;\u0026gt; D = {} \u0026gt;\u0026gt;\u0026gt; D[99] = \u0026#39;spam\u0026#39; \u0026gt;\u0026gt;\u0026gt; D[99] \u0026#39;spam\u0026#39; Using Dictionaries for Sparse Data Structures Dictionaries can represent sparse data structures. For example, a three-dimensional array where only a few positions are nonempty can be stored as:\n\u0026gt;\u0026gt;\u0026gt; Matrix = {} \u0026gt;\u0026gt;\u0026gt; Matrix[(2, 3, 4)] = 88 \u0026gt;\u0026gt;\u0026gt; Matrix[(7, 8, 9)] = 99 \u0026gt;\u0026gt;\u0026gt; Matrix[(2, 3, 4)] 88 Attempting to access a non-existent key results in a KeyError:\n\u0026gt;\u0026gt;\u0026gt; Matrix[(2, 3, 6)] # Raises KeyError To avoid such errors, use one of these methods:\nCheck key existence with in Use a try/except block Use the get() method with a default value: \u0026gt;\u0026gt;\u0026gt; Matrix.get((2, 3, 6), 0) 0 Using Dictionaries as “Records” Dictionaries are ideal for representing structured data similar to records or structs in other languages. For example:\n\u0026gt;\u0026gt;\u0026gt; rec = {} \u0026gt;\u0026gt;\u0026gt; rec[\u0026#39;name\u0026#39;] = \u0026#39;mel\u0026#39; \u0026gt;\u0026gt;\u0026gt; rec[\u0026#39;age\u0026#39;] = 45 \u0026gt;\u0026gt;\u0026gt; rec[\u0026#39;job\u0026#39;] = \u0026#39;trainer/writer\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(rec[\u0026#39;name\u0026#39;]) Mel They can also be nested to represent more complex information:\n\u0026gt;\u0026gt;\u0026gt; mel = { ... \u0026#39;name\u0026#39;: \u0026#39;Mark\u0026#39;, ... \u0026#39;jobs\u0026#39;: [\u0026#39;trainer\u0026#39;, \u0026#39;writer\u0026#39;], ... \u0026#39;web\u0026#39;: \u0026#39;www.rmi.net/~lutz\u0026#39;, ... \u0026#39;home\u0026#39;: {\u0026#39;state\u0026#39;: \u0026#39;CO\u0026#39;, \u0026#39;zip\u0026#39;: 80513} ... } \u0026gt;\u0026gt;\u0026gt; mel[\u0026#39;home\u0026#39;][\u0026#39;zip\u0026#39;] 80513 Sorting Dictionary Keys Since dictionaries are unordered, you can obtain a sorted list of keys when iterating:\n\u0026gt;\u0026gt;\u0026gt; D = {\u0026#39;a\u0026#39;: 1, \u0026#39;c\u0026#39;: 3, \u0026#39;b\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt; for key in sorted(D): ... print(key, D[key]) a 1 b 2 c 3 Note: In Python 3, D.keys() returns a view object, so you may need to convert it to a list before sorting, or simply use the sorted() function directly on the dictionary.\nChapter Summary Lists are mutable, ordered collections that support indexing, slicing, concatenation, and repetition. They can store heterogeneous data and be nested arbitrarily. List comprehensions offer a concise syntax for creating new lists from existing sequences. Changing lists in-place can be done via index or slice assignments and with methods such as append(), extend(), pop(), insert(), remove(), sort(), and reverse(). Dictionaries are mutable mappings that store key–value pairs, offering fast lookup by key. They are unordered by default. Basic dictionary operations include accessing, updating, deleting keys, and testing membership. They are ideal for representing sparse data, flexible lists, and structured records. Sorting dictionary keys and using methods like get() help manage dictionaries effectively. Together, lists and dictionaries provide powerful and flexible data structures that form the backbone of Python programming. They enable efficient data manipulation and are widely used in virtually every Python application.\n","permalink":"/chapters/chapter-7/","summary":"\u003cp\u003eThe list and dictionary object types are the main workhorses in almost all Python scripts. They are used to store, organize, and retrieve data efficiently. In this chapter, we cover how lists and dictionaries work, their basic operations, and how to modify them in-place.\u003c/p\u003e\n\u003chr\u003e\n\u003ch2 id=\"lists\"\u003eLists\u003c/h2\u003e\n\u003cp\u003eLists are ordered collections of arbitrary objects. Unlike strings, lists can contain any type of object—including numbers, strings, and even other lists. Lists are mutable, meaning you can change their contents in-place using assignment (to individual items or slices), method calls, deletion statements, and more. Key properties include:\u003c/p\u003e","title":"Chapter 7: Lists \u0026 Dictionaries"},{"content":" The file object is a commonly used and full-featured tool for processing files; the basic overview here is supplemented by larger examples in later chapters.\nTuples The last collection type in our survey is the Python tuple. Tuples construct simple groups of objects. They work exactly like lists, except that tuples can’t be changed in-place (they’re immutable) and are usually written as a series of items in parentheses, not square brackets. Although they don’t support as many methods, tuples share most of their properties with lists. Here’s a quick look at the basics.\nTuples are:\nOrdered collections of arbitrary objects: Like strings and lists, tuples are positionally ordered collections of objects (i.e., they maintain a left-to-right order among their contents) and can embed any kind of object. Accessed by offset: Items in a tuple are accessed by offset (not by key); they support all the offset-based access operations, such as indexing and slicing. Immutable sequences: Tuples support many of the same operations as strings and lists but are immutable; they don’t support any in-place change operations. Fixed-length, heterogeneous, and arbitrarily nestable: Because tuples are immutable, you cannot change their size without making a copy. However, they can hold any type of object—including other compound objects—allowing arbitrary nesting. Arrays of object references: Tuples are best thought of as object reference arrays; they store references to other objects, and indexing a tuple is relatively quick. Like lists, tuples are best thought of as object reference arrays; they store access points to other objects (references), and indexing a tuple is relatively quick. Table 9-1 highlights common tuple operations. A tuple is written as a series of objects (technically, expressions that generate objects), separated by commas and normally enclosed in parentheses. An empty tuple is just a pair of parentheses with nothing inside.\n[Table 1 Placeholder: Common tuple literals and operations]\nTuples in Action \u0026gt;\u0026gt;\u0026gt; (1, 2) + (3, 4) # Concatenation (1, 2, 3, 4) \u0026gt;\u0026gt;\u0026gt; (1, 2) * 4 # Repetition (1, 2, 1, 2, 1, 2, 1, 2) \u0026gt;\u0026gt;\u0026gt; T = (1, 2, 3, 4) \u0026gt;\u0026gt;\u0026gt; T[0], T[1:3] # Indexing, slicing (1, (2, 3)) Tuple Syntax Peculiarities: Commas and Parentheses The second and fourth entries in Table 1 merit a bit more explanation. Because parentheses can also enclose expressions, you need to do something special to tell Python when a single object in parentheses is a tuple and not a simple expression. If you really want a single-item tuple, simply add a trailing comma after the single item before the closing parenthesis:\n\u0026gt;\u0026gt;\u0026gt; x = (40) # An integer! \u0026gt;\u0026gt;\u0026gt; x 40 \u0026gt;\u0026gt;\u0026gt; y = (40,) # A tuple containing an integer \u0026gt;\u0026gt;\u0026gt; y (40,) As a special case, Python also allows you to omit the opening and closing parentheses for a tuple in contexts where it isn’t syntactically ambiguous. For instance, in an assignment statement, simply listing four items separated by commas is recognized as a tuple—even without parentheses.\nConversions, Methods, and Immutability Apart from literal syntax differences, tuple operations (the middle rows in Table 91) are identical to string and list operations. The only differences worth noting are that the +, *, and slicing operations return new tuples when applied to tuples, and that tuples don’t provide the same methods available for strings, lists, and dictionaries. If you want to sort a tuple, for example, you’ll usually have to first convert it to a list to access the sorting method or use the built-in sorted function:\n\u0026gt;\u0026gt;\u0026gt; T = (\u0026#39;cc\u0026#39;, \u0026#39;aa\u0026#39;, \u0026#39;dd\u0026#39;, \u0026#39;bb\u0026#39;) # Original tuple \u0026gt;\u0026gt;\u0026gt; tmp = list(T) # Make a list from a tuple\u0026#39;s items \u0026gt;\u0026gt;\u0026gt; tmp.sort() # Sort the list \u0026gt;\u0026gt;\u0026gt; tmp [\u0026#39;aa\u0026#39;, \u0026#39;bb\u0026#39;, \u0026#39;cc\u0026#39;, \u0026#39;dd\u0026#39;] \u0026gt;\u0026gt;\u0026gt; T = tuple(tmp) # Make a tuple from the list\u0026#39;s items \u0026gt;\u0026gt;\u0026gt; T (\u0026#39;aa\u0026#39;, \u0026#39;bb\u0026#39;, \u0026#39;cc\u0026#39;, \u0026#39;dd\u0026#39;) \u0026gt;\u0026gt;\u0026gt; sorted(T) # Or use the sorted built-in [\u0026#39;aa\u0026#39;, \u0026#39;bb\u0026#39;, \u0026#39;cc\u0026#39;, \u0026#39;dd\u0026#39;] Here, the list and tuple built-in functions convert the tuple to a list and then back to a tuple, effectively performing a conversion. List comprehensions can also convert tuples. For example, the following makes a list from a tuple, adding 20 to each item:\n\u0026gt;\u0026gt;\u0026gt; T = (1, 2, 3, 4, 5) \u0026gt;\u0026gt;\u0026gt; L = [x + 20 for x in T] \u0026gt;\u0026gt;\u0026gt; L [21, 22, 23, 24, 25] Although tuples don’t have the same methods as lists and strings, they do have two of their own (as of Python 2.6 and 3.0): index and count. These work as they do for lists:\n\u0026gt;\u0026gt;\u0026gt; T = (1, 2, 3, 2, 4, 2) # Example tuple \u0026gt;\u0026gt;\u0026gt; T.index(2) # Offset of first appearance of 2 1 \u0026gt;\u0026gt;\u0026gt; T.index(2, 2) # Offset of appearance after offset 23 \u0026gt;\u0026gt;\u0026gt; T.count(2) # How many 2s are there? 3 Note that the rule about tuple immutability applies only to the top level of the tuple itself, not to its contents. A list inside a tuple, for instance, can be changed:\n\u0026gt;\u0026gt;\u0026gt; T = (1, [2, 3], 4) \u0026gt;\u0026gt;\u0026gt; T[1] = \u0026#39;spam\u0026#39; # This fails: can\u0026#39;t change tuple itself Traceback (most recent call last): ... TypeError: object doesn\u0026#39;t support item assignment \u0026gt;\u0026gt;\u0026gt; T[1][0] = \u0026#39;spam\u0026#39; # This works: can change mutables inside \u0026gt;\u0026gt;\u0026gt; T (1, [\u0026#39;spam\u0026#39;, 3], 4) Why Lists and Tuples? A common question for beginners is: why do we need tuples if we have lists? Historically, Python’s creator viewed a tuple as a simple association of objects (constant by nature) and a list as a data structure that changes over time. The immutability of tuples provides integrity—once created, a tuple won’t be changed through another reference in a program. This makes tuples useful for roles similar to constant declarations and allows their use as dictionary keys. In general, use lists for ordered collections that might need to change and tuples for fixed associations.\nFiles You may already be familiar with files—named storage compartments on your computer managed by the operating system. The built-in open function creates a file object that links your Python program to an external file. Once opened, you can transfer strings of data to and from the file using its methods. File objects differ from numbers, sequences, or mappings because they primarily provide methods for common file-processing tasks (such as reading, writing, seeking, and flushing output buffers).\n[Table 2 Placeholder: Common file operations]\nOpening Files To open a file, call the built-in open function with the filename and a processing mode. The mode is typically:\n'r' to open for text input (the default) 'w' to create and open for text output 'a' to open for appending text to the end Additional mode options include:\nAdding a b to the mode string for binary data (disabling end-of-line translations and Unicode encodings). Adding a + to open the file for both input and output (allowing both reading and writing, often with seek operations). Both arguments to open must be strings, and an optional third argument can control output buffering (e.g., passing a zero means unbuffered output). If no directory path is provided, the file is assumed to exist in the current working directory.\nUsing Files Once a file object is created with open, you can call its methods to read from or write to the external file. File data is handled as strings in Python. Reading returns strings, and writing requires strings. Although there are many methods (some of which are listed in Table 2), here are a few usage notes:\nFile iterators are best for reading lines: Rather than reading the entire file at once, you can iterate over a file object to process one line at a time. Content is strings, not objects: Data read from a file is always returned as a string. You’ll need to convert it to another type if necessary. Likewise, Python does not automatically convert objects to strings when writing—you must format the string yourself. Additionally, advanced standard library tools (like the pickle and struct modules) can handle generic object storage and packed binary data.\nclose is usually optional: While Python automatically closes files when they are garbage-collected, it is good practice to manually close files to free operating system resources and flush output buffers. Files are buffered and seekable. The seek method allows you to jump to specific locations within a file for reading or writing.\nFiles in Action Let’s work through a simple example that demonstrates file-processing basics. The following code opens a new text file for output, writes two lines (each terminated with a newline marker, \\n), and closes the file. Later, the file is reopened in input mode and the lines are read one at a time with readline. Note that the third call to readline returns an empty string, indicating the end of the file.\n\u0026gt;\u0026gt;\u0026gt; myfile = open(\u0026#39;myfile.txt\u0026#39;, \u0026#39;w\u0026#39;) # Open for text output: create/empty \u0026gt;\u0026gt;\u0026gt; myfile.write(\u0026#39;hello text file\\n\u0026#39;) # Write a line of text: string 16 \u0026gt;\u0026gt;\u0026gt; myfile.write(\u0026#39;goodbye text file\\n\u0026#39;) # Write a line of text: string 18 \u0026gt;\u0026gt;\u0026gt; myfile.close() # Flush output buffers to disk \u0026gt;\u0026gt;\u0026gt; myfile = open(\u0026#39;myfile.txt\u0026#39;) # Open for text input: \u0026#39;r\u0026#39; is default \u0026gt;\u0026gt;\u0026gt; myfile.readline() # Read the first line back \u0026#39;hello text file\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; myfile.readline() # Read the next line back \u0026#39;goodbye text file\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; myfile.readline() # Empty string: end of file \u0026#39;\u0026#39; This example writes each line (including the end-of-line marker) explicitly. If you want to display the file’s content with interpreted newlines, you can read the entire file into a string and print it:\n\u0026gt;\u0026gt;\u0026gt; open(\u0026#39;myfile.txt\u0026#39;).read() # Read all at once into a string \u0026#39;hello text file\\ngoodbye text file\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; print(open(\u0026#39;myfile.txt\u0026#39;).read()) # User-friendly display hello text file goodbye text file To scan a text file line by line, file iterators are often the best option:\n\u0026gt;\u0026gt;\u0026gt; for line in open(\u0026#39;myfile\u0026#39;): ... print(line, end=\u0026#39;\u0026#39;) # Use file iterators, not reads ... hello text file goodbye text file When coded this way, the temporary file object created by open automatically reads one line per iteration. This method is simple, memory-efficient, and often faster than other options.\nText and Binary Files in Python 3.0 In both Python 3.0 and 2.6, file type is determined by the mode string passed to open—adding a b indicates binary mode. In Python 3.0 there is a sharper distinction:\nText files represent content as normal str strings, perform Unicode encoding/decoding automatically, and handle end-of-line translation. Binary files represent content as a special bytes type and provide access to file content unaltered. In Python 2.6, text files handle both 8-bit text and binary data with additional interfaces for Unicode. In practice, if your script deals with simple text, the file interface is largely the same between versions.\nFor example, when reading a binary file you get a bytes object:\n\u0026gt;\u0026gt;\u0026gt; data = open(\u0026#39;data.bin\u0026#39;, \u0026#39;rb\u0026#39;).read() # Open binary file: rb = read binary \u0026gt;\u0026gt;\u0026gt; data # Bytes string holds binary data b\u0026#39;\\x00\\x00\\x00\\x07spam\\x00\\x08\u0026#39; \u0026gt;\u0026gt;\u0026gt; data[4:8] # Act like strings b\u0026#39;spam\u0026#39; \u0026gt;\u0026gt;\u0026gt; data[0] # But really are small 8-bit integers 115 \u0026gt;\u0026gt;\u0026gt; bin(data[0]) # Python 3.0 bin() function \u0026#39;0b1110011\u0026#39; Binary files do not perform any end-of-line translation; text files automatically map all newline variations to \\n and handle Unicode encodings.\nStoring and Parsing Python Objects in Files The next example writes a variety of Python objects into a text file on multiple lines. Since file data is always stored as strings, you must convert objects to strings manually. (For brevity, byte-count return values from write are omitted.)\n\u0026gt;\u0026gt;\u0026gt; X, Y, Z = 43, 44, 45 # Native Python objects \u0026gt;\u0026gt;\u0026gt; S = \u0026#39;Spam\u0026#39; # Must be strings to store in file \u0026gt;\u0026gt;\u0026gt; D = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} \u0026gt;\u0026gt;\u0026gt; L = [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; F = open(\u0026#39;datafile.txt\u0026#39;, \u0026#39;w\u0026#39;) # Create output file \u0026gt;\u0026gt;\u0026gt; F.write(S + \u0026#39;\\n\u0026#39;) # Terminate lines with \\n \u0026gt;\u0026gt;\u0026gt; F.write(\u0026#39;%s,%s,%s\\n\u0026#39; % (X, Y, Z)) # Convert numbers to strings \u0026gt;\u0026gt;\u0026gt; F.write(str(L) + \u0026#39;$\u0026#39; + str(D) + \u0026#39;\\n\u0026#39;) # Convert and separate with $ \u0026gt;\u0026gt;\u0026gt; F.close() Once created, inspect the file’s contents by reading it into a string. The interactive echo shows the exact byte contents, while printing the string interprets newline characters:\n\u0026gt;\u0026gt;\u0026gt; chars = open(\u0026#39;datafile.txt\u0026#39;).read() # Raw string display \u0026gt;\u0026gt;\u0026gt; chars \u0026#34;Spam\\n43,44,45\\n[1, 2, 3]${\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2}\\n\u0026#34; \u0026gt;\u0026gt;\u0026gt; print(chars) # User-friendly display Spam 43,44,45 [1, 2, 3]${\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} To work with these strings as actual Python objects, further conversion is needed. For example, read the first line and remove its trailing newline:\n\u0026gt;\u0026gt;\u0026gt; F = open(\u0026#39;datafile.txt\u0026#39;) # Open again \u0026gt;\u0026gt;\u0026gt; line = F.readline() # Read one line \u0026gt;\u0026gt;\u0026gt; line \u0026#39;Spam\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; line.rstrip() \u0026#39;Spam\u0026#39; Next, read a line containing numbers and split it on commas:\n\u0026gt;\u0026gt;\u0026gt; line = F.readline() # Next line from file: it\u0026#39;s a string here \u0026gt;\u0026gt;\u0026gt; line \u0026#39;43,44,45\\n\u0026#39; \u0026gt;\u0026gt;\u0026gt; parts = line.split(\u0026#39;,\u0026#39;) # Split (parse) on commas \u0026gt;\u0026gt;\u0026gt; parts [\u0026#39;43\u0026#39;, \u0026#39;44\u0026#39;, \u0026#39;45\\n\u0026#39;] \u0026gt;\u0026gt;\u0026gt; int(parts[1]) # Convert from string to int 44 \u0026gt;\u0026gt;\u0026gt; numbers = [int(P) for P in parts] # Convert all in list at once \u0026gt;\u0026gt;\u0026gt; numbers [43, 44, 45] Finally, convert a stored list and dictionary (separated by $) using eval:\n\u0026gt;\u0026gt;\u0026gt; line = F.readline() \u0026gt;\u0026gt;\u0026gt; line \u0026#34;[1, 2, 3]${\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2}\\n\u0026#34; \u0026gt;\u0026gt;\u0026gt; parts = line.split(\u0026#39;$\u0026#39;) # Split (parse) on $ \u0026gt;\u0026gt;\u0026gt; parts [\u0026#39;[1, 2, 3]\u0026#39;, \u0026#34;{\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2}\\n\u0026#34;] \u0026gt;\u0026gt;\u0026gt; eval(parts[0]) [1, 2, 3] \u0026gt;\u0026gt;\u0026gt; objects = [eval(P) for P in parts] # Convert to any object type \u0026gt;\u0026gt;\u0026gt; objects [[1, 2, 3], {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2}] Storing Native Python Objects with pickle Using eval to convert strings to objects is powerful—but potentially dangerous. If you can’t trust the data source, use Python’s standard library pickle module to store native Python objects directly, without manual conversion.\nTo store a dictionary using pickle:\n\u0026gt;\u0026gt;\u0026gt; D = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} # Pickle any object to file \u0026gt;\u0026gt;\u0026gt; F = open(\u0026#39;datafile.pkl\u0026#39;, \u0026#39;wb\u0026#39;) \u0026gt;\u0026gt;\u0026gt; import pickle \u0026gt;\u0026gt;\u0026gt; pickle.dump(D, F) \u0026gt;\u0026gt;\u0026gt; F.close() To retrieve the dictionary later:\n\u0026gt;\u0026gt;\u0026gt; F = open(\u0026#39;datafile.pkl\u0026#39;, \u0026#39;rb\u0026#39;) \u0026gt;\u0026gt;\u0026gt; E = pickle.load(F) \u0026gt;\u0026gt;\u0026gt; E # Load any object from file {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2} The pickle module handles object serialization (converting objects to and from byte strings) with minimal effort. For more details, consult the Python standard library manual or use interactive help with import pickle.\nStoring and Parsing Packed Binary Data in Files Some advanced applications require handling packed binary data (perhaps created by a C program). Python’s standard library includes the struct module, which can both compose and parse packed binary data.\nTo create a packed binary data file, open it in binary write mode ('wb'), and use struct.pack with a format string and the appropriate Python objects. For example, the format string '\u0026gt;i4sh' specifies a 4-byte integer, a 4-character string, and a 2-byte integer (all in big-endian form):\n\u0026gt;\u0026gt;\u0026gt; F = open(\u0026#39;data.bin\u0026#39;, \u0026#39;wb\u0026#39;) # Open binary output file \u0026gt;\u0026gt;\u0026gt; import struct \u0026gt;\u0026gt;\u0026gt; data = struct.pack(\u0026#39;\u0026gt;i4sh\u0026#39;, 7, \u0026#39;spam\u0026#39;, 8) # Make packed binary \u0026gt;\u0026gt;\u0026gt; data b\u0026#39;\\x00\\x00\\x00\\x07spam\\x00\\x08\u0026#39; \u0026gt;\u0026gt;\u0026gt; F.write(data) # Write byte string \u0026gt;\u0026gt;\u0026gt; F.close() To parse the packed data back into Python objects:\n\u0026gt;\u0026gt;\u0026gt; F = open(\u0026#39;data.bin\u0026#39;, \u0026#39;rb\u0026#39;) \u0026gt;\u0026gt;\u0026gt; data = F.read() # Get packed binary data \u0026gt;\u0026gt;\u0026gt; data b\u0026#39;\\x00\\x00\\x00\\x07spam\\x00\\x08\u0026#39; \u0026gt;\u0026gt;\u0026gt; values = struct.unpack(\u0026#39;\u0026gt;i4sh\u0026#39;, data) # Convert to Python objects \u0026gt;\u0026gt;\u0026gt; values (7, \u0026#39;spam\u0026#39;, 8) ","permalink":"/chapters/chapter-8/","summary":"\u003chr\u003e\n\u003cp\u003eThe file object is a commonly used and full-featured tool for processing files; the basic overview here is supplemented by larger examples in later chapters.\u003c/p\u003e\n\u003ch2 id=\"tuples\"\u003eTuples\u003c/h2\u003e\n\u003cp\u003eThe last collection type in our survey is the Python tuple. Tuples construct simple groups of objects. They work exactly like lists, except that tuples can’t be changed in-place (they’re immutable) and are usually written as a series of items in parentheses, not square brackets. Although they don’t support as many methods, tuples share most of their properties with lists. Here’s a quick look at the basics.\u003c/p\u003e","title":"Chapter 8: Tuples, Files, and Everything Else"},{"content":" The statements are the things you write to tell Python what your programs should do. If programs “do things with stuff,” statements are the way you specify what sort of things a program does. Python is a procedural, statement-based language; by combining statements, you specify a procedure that Python performs to satisfy a program’s goals.\nPython Program Structure Revisited Another way to understand the role of statements is to revisit the concept hierarchy, which talked about built-in objects and the expressions used to manipulate them. The hierarchy levels are:\nPrograms are composed of modules. Modules contain statements. Statements contain expressions. Expressions create and process objects. At its core, Python syntax is composed of statements and expressions. Expressions process objects and are embedded in statements. Statements code the larger logic of a program’s operation—they use and direct expressions to process the objects we studied in the preceding chapters. Moreover, statements are where objects spring into existence (e.g., in expressions within assignment statements), and some statements create entirely new kinds of objects (functions, classes, and so on). Statements always exist in modules, which themselves are managed with statements.\nPython’s Statements Table 1 summarizes Python’s statement set. This part of the book deals with entries in the table from the top through break and continue. You’ve informally been introduced to a few of the statements in Table 10-1 already; this part of the book will fill in details that were skipped earlier, introduce the rest of Python’s procedural statement set, and cover the overall syntax model. Statements lower in Table 10-1 that have to do with larger program units—functions, classes, modules, and exceptions—lead to larger programming ideas, so they will each have a section of their own. More focused statements (like del, which deletes various components) are covered elsewhere in the book, or in Python’s standard manuals.\n[Table Placeholder: Python 3.0 statements]\nWhat Python Adds The one new syntax component in Python is the colon character (:). All Python compound statements (i.e., statements that have statements nested inside them) follow the same general pattern:\nHeader line: A statement header terminated by a colon. Nested statement block: A block of code indented underneath the header line. The colon is required, and omitting it is probably the most common coding mistake among new Python programmers—it’s certainly one I’ve witnessed thousands of times in Python training classes. In fact, if you are new to Python, you’ll almost certainly forget the colon character very soon. Most Python-friendly editors make this mistake easy to spot, and including it eventually becomes an unconscious habit.\nWhat Python Removes Although Python requires the extra colon character, there are three things programmers in C-like languages must include that you don’t generally have to in Python:\nParentheses are optional:\nIn many C-like languages, tests at the top of statements require parentheses:\nif (x \u0026lt; y) In Python, you simply omit the parentheses, and the statement works the same way:\nif x \u0026lt; y: End of line is end of statement:\nIn C-like languages, statements are terminated with semicolons:\nx = 1; In Python, the end of a line automatically terminates the statement. You can leave off the semicolons:\nx = 1 End of indentation is end of block:\nIn C-like languages, you need explicit markers (begin/end, then/endif, or braces) to indicate the start and end of a nested block:\nif (x \u0026gt; y) { x = 1; y = 2; } In Python, you consistently indent all the statements in a given nested block, and Python uses that physical indentation to determine where the block starts and stops:\nif x \u0026gt; y: x = 1 y = 2 Statement Rule Special Cases Although statements normally appear one per line, it is possible to squeeze more than one statement onto a single line in Python by separating them with semicolons:\na = 1; b = 2; print(a + b) # Three statements on one line This is the only place in Python where semicolons are required: as statement separators. This only works if the statements combined are simple statements (like assignments, prints, and function calls). Compound statements must still appear on separate lines.\nAnother special rule is that you can make a single statement span multiple lines by enclosing part of your statement in a bracketed pair—parentheses (), square brackets [], or curly braces {}. Any code enclosed in these constructs can cross multiple lines; the statement doesn’t end until Python reaches the closing part of the pair. For instance, to continue a list literal:\nmlist = [111, 222, 333] A Quick Example: Interactive Loops We’ll see all these syntax rules in action when we tour Python’s specific compound statements in the next few chapters, but they work the same throughout the language. To get started, let’s work through a brief, realistic example that demonstrates how statement syntax and nesting come together in practice.\nA Simple Interactive Loop Suppose you’re asked to write a Python program that interacts with a user in a console window. Whether you’re accepting inputs to send to a database or reading numbers for a calculation, you need to code a loop that reads one or more inputs from a user typing on a keyboard, and prints back a result for each. In Python, typical boilerplate code for such an interactive loop might look like this:\nwhile True: reply = input(\u0026#39;Enter text:\u0026#39;) if reply == \u0026#39;stop\u0026#39;: break print(reply.upper()) This code makes use of a few new ideas:\nWhile Loop: Uses the while loop, which repeats a block of code as long as its test condition is true. Input Function: Uses the input function to display a prompt and capture user input as a string. Single-line If Statement: Implements a single-line if statement to exit the loop if the reply is 'stop'. Break Statement: The break statement exits the loop immediately, so the program can continue after the loop. Doing Math on User Inputs Suppose that instead of converting a text string to uppercase, you want to perform math (e.g., squaring a number). If you try the following:\n\u0026gt;\u0026gt;\u0026gt; reply = \u0026#39;20\u0026#39; \u0026gt;\u0026gt;\u0026gt; reply ** 2 ...error text omitted... TypeError: unsupported operand type(s) for ** or pow(): \u0026#39;str\u0026#39; and \u0026#39;int\u0026#39; This error occurs because Python does not automatically convert strings to numbers. You must convert the string to an integer first:\n\u0026gt;\u0026gt;\u0026gt; int(reply) ** 2 400 Armed with this information, you can recode your loop to perform the necessary math. For example, type the following in a file to test it:\nwhile True: reply = input(\u0026#39;Enter text:\u0026#39;) if reply == \u0026#39;stop\u0026#39;: break print(int(reply) ** 2) print(\u0026#39;Bye\u0026#39;) This script exits on \u0026quot;stop\u0026quot; as before, but it also converts inputs to perform the required math.\nHandling Errors by Testing Inputs If the input is invalid (for example, non-numeric text), the built-in int function raises an exception:\nEnter text:xxx ...error text omitted... ValueError: invalid literal for int() with base 10: \u0026#39;xxx\u0026#39; To avoid this, you can check the string’s content using the isdigit method:\n\u0026gt;\u0026gt;\u0026gt; S = \u0026#39;123\u0026#39; \u0026gt;\u0026gt;\u0026gt; T = \u0026#39;xxx\u0026#39; \u0026gt;\u0026gt;\u0026gt; S.isdigit(), T.isdigit() (True, False) Using this, you can further nest your statements. Consider the following revised interactive script that avoids errors:\nwhile True: reply = input(\u0026#39;Enter text:\u0026#39;) if reply == \u0026#39;stop\u0026#39;: break elif not reply.isdigit(): print(\u0026#39;Bad!\u0026#39; * 8) else: print(int(reply) ** 2) print(\u0026#39;Bye\u0026#39;) Nesting Code Three Levels Deep Finally, consider another version of the script that branches based on the magnitude of valid input:\nwhile True: reply = input(\u0026#39;Enter text:\u0026#39;) if reply == \u0026#39;stop\u0026#39;: break elif not reply.isdigit(): print(\u0026#39;Bad!\u0026#39; * 8) else: num = int(reply) if num \u0026lt; 20: print(\u0026#39;low\u0026#39;) else: print(num ** 2) print(\u0026#39;Bye\u0026#39;) This example shows how you can nest code to multiple levels if needed.\n","permalink":"/chapters/chapter-9/","summary":"\u003chr\u003e\n\u003cp\u003eThe statements are the things you write to tell Python what your programs should do. If programs “do things with stuff,” statements are the way you specify what sort of things a program does. Python is a procedural, statement-based language; by combining statements, you specify a procedure that Python performs to satisfy a program’s goals.\u003c/p\u003e\n\u003ch2 id=\"python-program-structure-revisited\"\u003ePython Program Structure Revisited\u003c/h2\u003e\n\u003cp\u003eAnother way to understand the role of statements is to revisit the concept hierarchy, which talked about built-in objects and the expressions used to manipulate them. The hierarchy levels are:\u003c/p\u003e","title":"Chapter 9: Introducing Python Statements"},{"content":"This chapter presents the Python if statement, the main tool for selecting from alternative actions based on test results. Because this is our first in-depth look at compound statements—statements that embed other statements—we also explore the general concepts behind Python’s statement syntax model.\nif Statements In simple terms, the Python if statement selects actions to perform. It is the primary selection tool in Python and represents much of the logic a Python program possesses. Being a compound statement, an if statement may contain other statements, including additional if statements. Python lets you combine statements sequentially (so they execute one after another) and nest them arbitrarily (so they execute only under certain conditions).\nGeneral Format The Python if statement is typical of those in most procedural languages. It takes the form of an if test, followed by one or more optional elif (\u0026ldquo;else if\u0026rdquo;) tests and a final optional else block. Each test and the else part has an associated block of nested statements indented under a header line. When the if statement runs, Python executes the block associated with the first test that evaluates to true, or the else block if all tests prove false.\nThe general form is:\nif \u0026lt;test1\u0026gt;: \u0026lt;statements1\u0026gt; elif \u0026lt;test2\u0026gt;: \u0026lt;statements2\u0026gt; else: \u0026lt;statements3\u0026gt; # if test (Associated block, Optional elifs, Optional else)\nMultiway Branching Consider this example of a more complex if statement with all its optional parts present:\n\u0026gt;\u0026gt;\u0026gt; x = \u0026#39;killer rabbit\u0026#39; \u0026gt;\u0026gt;\u0026gt; if x == \u0026#39;roger\u0026#39;: ... print(\u0026#34;how\u0026#39;s jessica?\u0026#34;) ... elif x == \u0026#39;bugs\u0026#39;: ... print(\u0026#34;what\u0026#39;s up doc?\u0026#34;) ... else: ... print(\u0026#39;Run away! Run away!\u0026#39;) ... Run away! Run away! This multiline statement extends from the if line through the else block. When executed, Python runs the block under the first test that is true, or the else block if all tests are false. In practice, both the elif and else parts may be omitted, and each section may contain more than one statement. Note that the keywords if, elif, and else are aligned vertically by virtue of their identical indentation.\nMultiway branching can also be coded by indexing dictionaries or searching lists. Because dictionaries and lists can be built at runtime, they are sometimes more flexible than hardcoded if logic. For example:\n\u0026gt;\u0026gt;\u0026gt; choice = \u0026#39;ham\u0026#39; \u0026gt;\u0026gt;\u0026gt; print({\u0026#39;spam\u0026#39;: 1.25, ... \u0026#39;ham\u0026#39;: 1.99, ... \u0026#39;eggs\u0026#39;: 0.99, ... \u0026#39;bacon\u0026#39;: 1.10}[choice]) 1.99 # A dictionary-based \u0026lsquo;switch\u0026rsquo; – Use has_key or get for default\nAlthough it might take a few moments to sink in, this dictionary indexing is a multiway branch—indexing on the key choice branches to one of a set of values, much like a switch in C. An equivalent but more verbose if statement might look like this:\n\u0026gt;\u0026gt;\u0026gt; if choice == \u0026#39;spam\u0026#39;: ... print(1.25) ... elif choice == \u0026#39;ham\u0026#39;: ... print(1.99) ... elif choice == \u0026#39;eggs\u0026#39;: ... print(0.99) ... elif choice == \u0026#39;bacon\u0026#39;: ... print(1.10) ... else: ... print(\u0026#39;Bad choice\u0026#39;) ... 1.99 Notice the else clause to handle the default case when no key matches. The same technique can be used with dictionary methods to supply a default. For example, using get:\n\u0026gt;\u0026gt;\u0026gt; branch = {\u0026#39;spam\u0026#39;: 1.25, ... \u0026#39;ham\u0026#39;: 1.99, ... \u0026#39;eggs\u0026#39;: 0.99} \u0026gt;\u0026gt;\u0026gt; print(branch.get(\u0026#39;spam\u0026#39;, \u0026#39;Bad choice\u0026#39;)) 1.25 \u0026gt;\u0026gt;\u0026gt; print(branch.get(\u0026#39;bacon\u0026#39;, \u0026#39;Bad choice\u0026#39;)) Bad choice An in-membership test in an if statement can have the same effect:\n\u0026gt;\u0026gt;\u0026gt; choice = \u0026#39;bacon\u0026#39; \u0026gt;\u0026gt;\u0026gt; if choice in branch: ... print(branch[choice]) ... else: ... print(\u0026#39;Bad choice\u0026#39;) ... Bad choice Truth Tests Since the if statement is the first statement that directly uses test results, it is important to understand Python’s Boolean logic. In Python:\nAny nonzero number or nonempty object is true. Zero numbers, empty objects, and the special object None are considered false. Comparisons and equality tests are applied recursively to data structures and return True or False. Boolean operators and, or, and not combine truth values or expressions that return truth values. There are three Boolean expression operators in Python:\nX and Y\nIs true if both X and Y are true.\nX or Y\nIs true if either X or Y is true.\nnot X\nIs true if X is false (the expression returns True or False).\nHere, X and Y can be any truth value or any expression that returns a truth value (for example, an equality test or a range comparison). Note that these operators are spelled out as words (instead of symbols like \u0026amp;\u0026amp;, ||, and ! in C).\nConsider these examples:\n\u0026gt;\u0026gt;\u0026gt; 2 \u0026lt; 3, 3 \u0026lt; 2 (True, False) # Less-than: returns True or False (1 or 0)\nThe and and or operators do not always return True or False—they return one of their operands, based on short-circuit evaluation. For instance:\n\u0026gt;\u0026gt;\u0026gt; 2 or 3, 3 or 2 (2, 3) \u0026gt;\u0026gt;\u0026gt; [] or 3 3 \u0026gt;\u0026gt;\u0026gt; [] or {} {} # Return left operand if true; else, return right operand (which is inherently true or false)\nSimilarly, and operations stop as soon as the result is known. Python evaluates operands from left to right and stops at the first false operand:\n\u0026gt;\u0026gt;\u0026gt; 2 and 3, 3 and 2 (3, 2) \u0026gt;\u0026gt;\u0026gt; [] and {} [] \u0026gt;\u0026gt;\u0026gt; 3 and [] [] # In an \u0026ldquo;and\u0026rdquo; operation, if the left operand is false, it is returned immediately; otherwise, the right operand is returned.\nExamples (if Statements) Simple if/else test:\nIf num is over 10, display “This is over 10”, otherwise display “This is not over 10”.\nif num \u0026gt; 10: print(\u0026#34;This is over 10\u0026#34;) else: print(\u0026#34;This is not over 10\u0026#34;) if/elif/else test:\nIf num is over 10, display “This is over 10”; if num is equal to 10, display “This is equal to 10”; otherwise, display “This is under 10”.\nif num \u0026gt; 10: print(\u0026#34;This is over 10\u0026#34;) elif num == 10: print(\u0026#34;This is equal to 10\u0026#34;) else: print(\u0026#34;This is under 10\u0026#34;) Nested if statement:\nIf num is 10 or more, test further to see if num is less than or equal to 20.\nIf yes, display “This is between 10 and 20”. If not, display “This is over 20”.\nIf num is not over 10, display “This is under 10”. if num \u0026gt;= 10: if num \u0026lt;= 20: print(\u0026#34;This is between 10 and 20\u0026#34;) else: print(\u0026#34;This is over 20\u0026#34;) else: print(\u0026#34;This is under 10\u0026#34;) Changing text to lower case:\nPython is case sensitive. This converts the user input to lower case for easier comparison.\ntext = str.lower(text) Using and to test multiple conditions:\nBoth conditions must be met to produce the output “Thank you”.\nnum = int(input(\u0026#34;Enter a number between 10 and 20: \u0026#34;)) if num \u0026gt;= 10 and num \u0026lt;= 20: print(\u0026#34;Thank you\u0026#34;) else: print(\u0026#34;Out of range\u0026#34;) Using or to test conditions:\nJust one condition must be met to display “Thank you”.\nnum = int(input(\u0026#34;Enter an EVEN number between 1 and 5: \u0026#34;)) if num == 2 or num == 4: print(\u0026#34;Thank you\u0026#34;) else: print(\u0026#34;Incorrect\u0026#34;) Comparing two numbers:\nAsk for two numbers. If the first is larger than the second, display the second number first; otherwise, display the first number first.\nnum1 = int(input(\u0026#34;Enter the first number: \u0026#34;)) num2 = int(input(\u0026#34;Enter the second number: \u0026#34;)) if num1 \u0026gt; num2: print(num2, num1) else: print(num1, num2) Number under 20 check:\nAsk the user to enter a number under 20. If they enter a number that is 20 or more, display “Too high”; otherwise, display “Thank you”.\nnum = int(input(\u0026#34;Enter a number under 20: \u0026#34;)) if num \u0026gt;= 20: print(\u0026#34;Too high\u0026#34;) else: print(\u0026#34;Thank you\u0026#34;) Number between 10 and 20 check:\nAsk the user to enter a number between 10 and 20 (inclusive).\nIf the number is within this range, display “Thank you”. Otherwise, display “Incorrect answer”. num = int(input(\u0026#34;Enter a number between 10 and 20: \u0026#34;)) if num \u0026gt;= 10 and num \u0026lt;= 20: print(\u0026#34;Thank you\u0026#34;) else: print(\u0026#34;Incorrect answer\u0026#34;) Favorite color check:\nAsk the user to enter their favorite color.\nIf they enter “red”, “RED”, or “Red”, display “I like red too”. Otherwise, display “I don’t like [colour], I prefer red”. color = input(\u0026#34;Enter your favorite color: \u0026#34;) if color == \u0026#34;red\u0026#34; or color == \u0026#34;RED\u0026#34; or color == \u0026#34;Red\u0026#34;: print(\u0026#34;I like red too\u0026#34;) else: print(f\u0026#34;I don\u0026#39;t like {color}, I prefer red\u0026#34;) Raining and windy check:\nAsk the user if it is raining and convert the answer to lower case.\nIf the answer is “yes”, ask if it is windy. If it is windy, display “It is too windy for an umbrella”. Otherwise, display “Take an umbrella”. If it is not raining, display “Enjoy your day”. raining = input(\u0026#34;Is it raining? \u0026#34;).lower() if raining == \u0026#34;yes\u0026#34;: windy = input(\u0026#34;Is it windy? \u0026#34;).lower() if windy == \u0026#34;yes\u0026#34;: print(\u0026#34;It is too windy for an umbrella\u0026#34;) else: print(\u0026#34;Take an umbrella\u0026#34;) else: print(\u0026#34;Enjoy your day\u0026#34;) Age-based messages:\nAsk the user for their age.\nIf they are 18 or over, display “You can vote”. If they are 17, display “You can learn to drive”. If they are 16, display “You can buy a lottery ticket”. If they are under 16, display “You can go Trick-or-Treating”. age = int(input(\u0026#34;Enter your age: \u0026#34;)) if age \u0026gt;= 18: print(\u0026#34;You can vote\u0026#34;) elif age == 17: print(\u0026#34;You can learn to drive\u0026#34;) elif age == 16: print(\u0026#34;You can buy a lottery ticket\u0026#34;) else: print(\u0026#34;You can go Trick-or-Treating\u0026#34;) Number range evaluation:\nAsk the user to enter a number.\nIf it is under 10, display “Too low”. If the number is between 10 and 20, display “Correct”. Otherwise, display “Too high”. num = int(input(\u0026#34;Enter a number: \u0026#34;)) if num \u0026lt; 10: print(\u0026#34;Too low\u0026#34;) elif 10 \u0026lt;= num \u0026lt;= 20: print(\u0026#34;Correct\u0026#34;) else: print(\u0026#34;Too high\u0026#34;) Choice selection:\nAsk the user to enter 1, 2, or 3.\nIf they enter 1, display “Thank you”. If they enter 2, display “Well done”. If they enter 3, display “Correct”. If they enter anything else, display “Error message”. choice = int(input(\u0026#34;Enter 1, 2, or 3: \u0026#34;)) if choice == 1: print(\u0026#34;Thank you\u0026#34;) elif choice == 2: print(\u0026#34;Well done\u0026#34;) elif choice == 3: print(\u0026#34;Correct\u0026#34;) else: print(\u0026#34;Error message\u0026#34;) Chapter 10 Summary: if Tests and Syntax Rules This chapter introduces the Python if statement as the fundamental tool for making decisions in a program. It explains how conditional tests are used to determine which block of code executes, forming the basis of program logic.\nKey points include:\nCompound Statements:\nThe if statement is the first compound statement discussed. It can include nested statements and even other if statements, allowing for complex decision structures.\nGeneral Structure:\nThe chapter describes the standard format for an if statement, which consists of:\nAn if test followed by a block of associated statements. Optional elif (\u0026ldquo;else if\u0026rdquo;) tests with their own blocks. An optional else block that executes if none of the tests are true.\nEach block is defined by its indentation rather than explicit markers. Multiway Branching:\nIt explains how to implement multiway branching by combining multiple conditions, either through a series of if/elif/else statements or by using alternative structures like dictionary indexing for selecting among several options.\nDefault Actions:\nThe chapter discusses methods for handling default cases when none of the specified conditions are met, emphasizing the use of an else clause or dictionary methods (like get) to supply fallback values.\nTruth Tests and Boolean Logic:\nThe chapter outlines Python’s approach to evaluating truth values:\nAny nonzero number or nonempty object is considered true. Zero, empty objects, and None are considered false. Comparisons and equality tests produce boolean results. Boolean operators (and, or, and not) are used to combine tests and support short-circuit evaluation, meaning that evaluation stops as soon as the outcome is determined. Overall, the chapter lays a foundation for understanding how Python makes decisions based on conditions, providing the basis for controlling program flow through well-structured, readable syntax.\n","permalink":"/chapters/chapter-10/","summary":"\u003cp\u003eThis chapter presents the Python \u003cstrong\u003eif\u003c/strong\u003e statement, the main tool for selecting from alternative actions based on test results. Because this is our first in-depth look at compound statements—statements that embed other statements—we also explore the general concepts behind Python’s statement syntax model.\u003c/p\u003e\n\u003ch2 id=\"if-statements\"\u003eif Statements\u003c/h2\u003e\n\u003cp\u003eIn simple terms, the Python \u003cstrong\u003eif\u003c/strong\u003e statement selects actions to perform. It is the primary selection tool in Python and represents much of the logic a Python program possesses. Being a compound statement, an \u003cstrong\u003eif\u003c/strong\u003e statement may contain other statements, including additional \u003cstrong\u003eif\u003c/strong\u003e statements. Python lets you combine statements sequentially (so they execute one after another) and nest them arbitrarily (so they execute only under certain conditions).\u003c/p\u003e","title":"Chapter 10: if Tests and Syntax Rules"},{"content":"This chapter presents two main looping constructs—statements that repeat an action over and over. The first is the while statement, which provides a way to code general loops, and the second is the for statement, which is designed for stepping through the items in a sequence object and running a block of code for each.\nwhile Loops Python’s while statement is the most general iteration construct in the language. In simple terms, it repeatedly executes a block of indented statements as long as a test at the top keeps evaluating to a true value. Control loops back to the start of the statement until the test becomes false. When the test becomes false, control passes to the statement following the while block. If the test is false from the beginning, the loop body never runs.\nGeneral Format In its most complex form, the while statement consists of:\nA header line with a test expression. A body of one or more indented statements. An optional else part that is executed if control exits the loop without a break statement. while \u0026lt;test\u0026gt;: # Loop test \u0026lt;statements1\u0026gt; # Loop body else: # Run if loop didn\u0026#39;t exit with break \u0026lt;statements2\u0026gt; Examples Infinite Loop Example:\nwhile True: print(\u0026#39;Type Ctrl-C to stop me!\u0026#39;) Slicing Characters from a String:\nx = \u0026#39;spam\u0026#39; while x: # While x is not empty print(x, end=\u0026#39; \u0026#39;) # Print current value of x on the same line x = x[1:] # Strip first character off x The end=' ' argument places all outputs on the same line separated by a space.\nCounter Loop Example:\na = 0; b = 10 while a \u0026lt; b: print(a, end=\u0026#39; \u0026#39;) # Print a with a trailing space a += 1 # Increment a (or use: a = a + 1) Simulating a “do until” Loop:\nwhile True: # loop body... if exitTest(): break # Exit loop if exitTest() returns True break, continue, pass, and the Loop else Python provides several simple one-word statements that only make sense inside loops.\nbreak: Jumps out of the closest enclosing loop. continue: Jumps to the top of the closest enclosing loop. pass: Does nothing at all; it’s an empty statement placeholder. Loop else block: Runs if and only if the loop is exited normally (i.e., without encountering a break). General Loop Format (with break and continue) while \u0026lt;test1\u0026gt;: \u0026lt;statements1\u0026gt; if \u0026lt;test2\u0026gt;: break # Exit loop now if \u0026lt;test2\u0026gt; is true if \u0026lt;test3\u0026gt;: continue # Skip to next iteration if \u0026lt;test3\u0026gt; is true else: # Run if we didn\u0026#39;t hit a \u0026#39;break\u0026#39; \u0026lt;statements2\u0026gt; Using pass in a Loop To code an infinite loop that does nothing each time through, use:\nwhile True: pass # Type Ctrl-C to stop me! Using continue to Skip Iterations The continue statement causes an immediate jump to the top of the loop. For example, to skip odd numbers when counting down:\nx = 10 while x: x = x - 1 # Or use: x -= 1 if x % 2 != 0: continue # If x is odd, skip printing print(x, end=\u0026#39; \u0026#39;) Using break to Exit a Loop The break statement causes an immediate exit from a loop. For example, an interactive loop that exits when the user enters \u0026ldquo;stop\u0026rdquo;:\nwhile True: name = input(\u0026#39;Enter name:\u0026#39;) # Prompt for a name if name == \u0026#39;stop\u0026#39;: break # Exit loop if name is \u0026#39;stop\u0026#39; age = input(\u0026#39;Enter age: \u0026#39;) # Prompt for age print(\u0026#39;Hello\u0026#39;, name, \u0026#39;=\u0026gt;\u0026#39;, int(age) ** 2) Loop else Clause Example The loop else clause can eliminate the need for search status flags. For example, determining if a positive integer y is prime:\nx = y // 2 # Start checking at half of y while x \u0026gt; 1: if y % x == 0: print(y, \u0026#39;has factor\u0026#39;, x) # A factor is found break # Exit the loop x -= 1 else: print(y, \u0026#39;is prime\u0026#39;) # No factor found; y is prime Another example with string processing:\nwhile x: if match(x[0]): print(\u0026#39;Ni\u0026#39;) break x = x[1:] else: print(\u0026#39;Not found\u0026#39;) # Printed only if loop exhausts x without a break for Loops The for loop is a generic sequence iterator in Python that steps through the items in any ordered sequence—such as strings, lists, tuples, and other iterables.\nGeneral Format The for loop begins with a header line that specifies an assignment target and the sequence to step through. This is followed by an indented block of statements.\nfor \u0026lt;target\u0026gt; in \u0026lt;object\u0026gt;: # Assign each item from the sequence to \u0026lt;target\u0026gt; \u0026lt;statements\u0026gt; # Repeated loop body that uses \u0026lt;target\u0026gt; else: \u0026lt;statements\u0026gt; # Runs if we didn\u0026#39;t hit a \u0026#39;break\u0026#39; Basic Usage For example, iterating over a list:\nfor x in [\u0026#34;spam\u0026#34;, \u0026#34;eggs\u0026#34;, \u0026#34;ham\u0026#34;]: print(x, end=\u0026#39; \u0026#39;) This prints each item on the same line.\nSumming and Multiplying Items sum = 0 for x in [1, 2, 3, 4]: sum = sum + x # Add each item to sum print(sum) # Output: 10 prod = 1 for item in [1, 2, 3, 4]: prod *= item # Multiply each item into prod print(prod) # Output: 24 Iterating Over Different Data Types For loops work on strings and tuples as well:\nS = \u0026#34;lumberjack\u0026#34; T = (\u0026#34;and\u0026#34;, \u0026#34;I\u0026#39;m\u0026#34;, \u0026#34;okay\u0026#34;) for x in S: print(x, end=\u0026#39; \u0026#39;) # Iterate over a string for x in T: print(x, end=\u0026#39; \u0026#39;) # Iterate over a tuple Tuple Assignment in for Loops When iterating through a sequence of tuples, you can unpack the tuple directly in the loop header:\nT = [(1, 2), (3, 4), (5, 6)] for (a, b) in T: print(a, b) # Tuple assignment at work You can also iterate through dictionary items:\nD = {\u0026#39;a\u0026#39;: 1, \u0026#39;b\u0026#39;: 2, \u0026#39;c\u0026#39;: 3} for key in D: print(key, \u0026#39;=\u0026gt;\u0026#39;, D[key]) # Using dict keys and indexing print(list(D.items())) # Show list of (key, value) tuples for (key, value) in D.items(): print(key, \u0026#39;=\u0026gt;\u0026#39;, value) # Iterate over both keys and values Alternatively, manual unpacking is also possible:\nT = [(1, 2), (3, 4), (5, 6)] for both in T: a, b = both # Manual assignment equivalent to tuple unpacking print(a, b) Nested sequence structures can also be unpacked automatically:\n((a, b), c) = ((1, 2), 3) print(a, b, c) # Output: 1 2 3 for ((a, b), c) in [((1, 2), 3), ((4, 5), 6)]: print(a, b, c) for ((a, b), c) in [([1, 2], 3), [\u0026#39;XY\u0026#39;, 6]]: print(a, b, c) Nested for Loops and Loop else Clause The following example searches for each key in a list of items and reports whether it was found:\nitems = [\u0026#34;aaa\u0026#34;, 111, (4, 5), 2.01] tests = [(4, 5), 3.14] for key in tests: for item in items: if item == key: print(key, \u0026#34;was found\u0026#34;) break else: print(key, \u0026#34;not found!\u0026#34;) # Loop else: executed if inner loop did not hit break This example can be simplified by using the in operator:\nfor key in tests: if key in items: print(key, \u0026#34;was found\u0026#34;) else: print(key, \u0026#34;not found!\u0026#34;) Collecting Common Items from Sequences seq1 = \u0026#34;spam\u0026#34; seq2 = \u0026#34;scam\u0026#34; res = [] # Start with an empty list for x in seq1: # Scan first sequence if x in seq2: # If common item is found res.append(x) # Add to result list print(res) Loop Coding Techniques The for loop subsumes most counter-style loops. It is generally simpler to code and quicker to run than a while loop. However, there are cases where you need specialized iterations (e.g., visiting every second or third item, or traversing multiple sequences in parallel). Python provides two built-in functions to help with these tasks: range and zip.\nCounter Loops: while and range The range function generates a series of integers and is commonly used to generate indices in a for loop. In Python 3, range is an iterator, so you may need to convert it to a list to display its results:\nprint(list(range(5)), list(range(2, 5)), list(range(0, 10, 2))) # Output: ([0, 1, 2, 3, 4], [2, 3, 4], [0, 2, 4, 6, 8]) With one argument, it generates integers from zero up to (but not including) the argument’s value. With two arguments, the first is the lower bound. An optional third argument specifies the step:\nprint(list(range(-5, 5))) # Output: [-5, -4, -3, -2, -1, 0, 1, 2, 3, 4] print(list(range(5, -5, -1))) # Output: [5, 4, 3, 2, 1, 0, -1, -2, -3, -4] Ranges are handy within for loops. For example, to print three lines:\nfor i in range(3): print(i, \u0026#39;Pythons\u0026#39;) Range is also used for indirect sequence iteration. For instance, to iterate over a string using indices:\nX = \u0026#39;spam\u0026#39; for i in range(len(X)): print(X[i], end=\u0026#39; \u0026#39;) However, it is usually best to iterate directly over the sequence:\nfor item in X: print(item) Skipping Items with range and Slices To visit every second item in a string:\nS = \u0026#39;abcdefghijk\u0026#39; print(list(range(0, len(S), 2))) # Output: [0, 2, 4, 6, 8, 10] for i in range(0, len(S), 2): print(S[i], end=\u0026#39; \u0026#39;) A simpler method is to use slicing:\nfor c in S[::2]: print(c, end=\u0026#39; \u0026#39;) Modifying a List During Iteration A simple for loop that modifies each item does not change the original list:\nL = [1, 2, 3, 4, 5] for x in L: x += 1 print(L) # Output: [1, 2, 3, 4, 5] To change the list in-place, use indexing with range:\nL = [1, 2, 3, 4, 5] for i in range(len(L)): L[i] += 1 # Or L[i] = L[i] + 1 print(L) # Output: [2, 3, 4, 5, 6] A while loop alternative is:\ni = 0 while i \u0026lt; len(L): L[i] += 1 i += 1 print(L) # Output: [3, 4, 5, 6, 7] A list comprehension can also be used to create a modified list without changing the original in-place:\nnew_L = [x + 1 for x in L] Parallel Traversals: zip and map The zip function allows for parallel iteration over multiple sequences. For example, given two lists:\nL1 = [1, 2, 3, 4] L2 = [5, 6, 7, 8] print(list(zip(L1, L2))) # Output: [(1, 5), (2, 6), (3, 7), (4, 8)] Using zip with a for loop:\nfor (x, y) in zip(L1, L2): print(x, y, \u0026#39;--\u0026#39;, x + y) Zip can also accept more than two sequences. With three sequences:\nT1, T2, T3 = (1, 2, 3), (4, 5, 6), (7, 8, 9) print(list(zip(T1, T2, T3))) # Output: [(1, 4, 7), (2, 5, 8), (3, 6, 9)] If the sequences differ in length, zip truncates the result to the length of the shortest sequence:\nS1 = \u0026#39;abc\u0026#39; S2 = \u0026#39;xyz123\u0026#39; print(list(zip(S1, S2))) # Output: [(\u0026#39;a\u0026#39;, \u0026#39;x\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;y\u0026#39;), (\u0026#39;c\u0026#39;, \u0026#39;z\u0026#39;)] In Python 2.x, the built-in map function could be used to pair items from sequences and would pad shorter sequences with None. (This behavior is not supported in Python 3.x.)\nFor example (Python 2.x only):\nprint(map(None, S1, S2)) # Output: [(\u0026#39;a\u0026#39;, \u0026#39;x\u0026#39;), (\u0026#39;b\u0026#39;, \u0026#39;y\u0026#39;), (\u0026#39;c\u0026#39;, \u0026#39;z\u0026#39;), (None, \u0026#39;1\u0026#39;), (None, \u0026#39;2\u0026#39;), (None, \u0026#39;3\u0026#39;)] A common usage of map in Python 3.x is to apply a function to every item in a sequence:\nprint(list(map(ord, \u0026#39;spam\u0026#39;))) # Output: [115, 112, 97, 109] Dictionary Construction with zip When keys and values are obtained as lists at runtime, zip can be used to create a dictionary:\nkeys = [\u0026#39;spam\u0026#39;, \u0026#39;eggs\u0026#39;, \u0026#39;toast\u0026#39;] vals = [1, 3, 5] print(list(zip(keys, vals))) # Output: [(\u0026#39;spam\u0026#39;, 1), (\u0026#39;eggs\u0026#39;, 3), (\u0026#39;toast\u0026#39;, 5)] D2 = {} for (k, v) in zip(keys, vals): D2[k] = v print(D2) # Output: {\u0026#39;spam\u0026#39;: 1, \u0026#39;eggs\u0026#39;: 3, \u0026#39;toast\u0026#39;: 5} Generating Both Offsets and Items: enumerate The built-in enumerate function provides both the index (offset) and the item during iteration:\nTraditional approach:\nS = \u0026#39;spam\u0026#39; offset = 0 for item in S: print(item, \u0026#39;appears at offset\u0026#39;, offset) offset += 1 Using enumerate:\nS = \u0026#39;spam\u0026#39; for (offset, item) in enumerate(S): print(item, \u0026#39;appears at offset\u0026#39;, offset) The enumerate function returns an iterator that yields (index, value) tuples. You can also use the next function to retrieve these tuples manually:\nE = enumerate(S) print(E) # Shows the enumerate object print(next(E)) # Output: (0, \u0026#39;s\u0026#39;) print(next(E)) # Output: (1, \u0026#39;p\u0026#39;) print(next(E)) # Output: (2, \u0026#39;a\u0026#39;) ","permalink":"/chapters/chapter-11/","summary":"\u003cp\u003eThis chapter presents two main looping constructs—statements that repeat an action over and over. The first is the \u003cstrong\u003ewhile\u003c/strong\u003e statement, which provides a way to code general loops, and the second is the \u003cstrong\u003efor\u003c/strong\u003e statement, which is designed for stepping through the items in a sequence object and running a block of code for each.\u003c/p\u003e\n\u003ch2 id=\"while-loops\"\u003ewhile Loops\u003c/h2\u003e\n\u003cp\u003ePython’s \u003cstrong\u003ewhile\u003c/strong\u003e statement is the most general iteration construct in the language. In simple terms, it repeatedly executes a block of indented statements as long as a test at the top keeps evaluating to a true value. Control loops back to the start of the statement until the test becomes false. When the test becomes false, control passes to the statement following the while block. If the test is false from the beginning, the loop body never runs.\u003c/p\u003e","title":"Chapter 11: While and For loops"},{"content":"In the previous part, we looked at basic procedural statements in Python. Here, we move on to explore a set of additional statements that we can use to create functions of our own. In simple terms, a function is a device that groups a set of statements so they can be run more than once in a program. Functions can compute a result value and allow us to specify parameters that serve as function inputs, which may differ each time the code is run. Coding an operation as a function makes it a generally useful tool that can be used in a variety of contexts.\nMore fundamentally, functions are the alternative to programming by cutting and pasting—rather than having multiple redundant copies of an operation’s code, we can factor it into a single function. In so doing, we reduce our future work radically: if the operation must be changed later, we update only one copy rather than many. Functions are the most basic program structure Python provides for maximizing code reuse and minimizing redundancy, and they are also a design tool that lets us split complex systems into manageable parts.\n[Table Placeholder: Primary function-related tools]\nWhy Use Functions? Functions are a nearly universal program-structuring device. You may have encountered them before in other languages, where they may have been called subroutines or procedures. In Python, functions serve two primary roles:\nMaximizing Code Reuse and Minimizing Redundancy:\nFunctions are the simplest way to package logic for use in more than one place and at more than one time. Rather than writing duplicate code, you define the operation once and call it as needed.\nProcedural Decomposition:\nFunctions help you split complex tasks into smaller, well-defined parts. For example, making a pizza involves mixing the dough, rolling it out, adding toppings, baking, etc. Each of these subtasks can be encapsulated in its own function, making the overall process easier to manage.\nCoding Functions Although we have already used some built-in functions (like open and len), we now explore how to write new functions in Python. Functions we write behave the same way as the built-ins: they are called in expressions, passed values, and return results.\nCore Concepts def is Executable Code:\nPython functions are defined with the def statement. Unlike functions in compiled languages (e.g., C), def is an executable statement. The function does not exist until Python reaches and runs the def. It is even legal (and occasionally useful) to nest def statements inside if statements, loops, or other functions.\ndef Creates an Object and Assigns It to a Name:\nWhen Python runs a def statement, it creates a new function object and assigns it to the given name. Function objects can be assigned to other names, stored in data structures, and can have arbitrary attributes attached.\nlambda Creates an Object and Returns It:\nFunctions may also be created with the lambda expression. This allows in-line function definitions in contexts where a def statement is not syntactically permitted.\nreturn Sends a Result Back to the Caller:\nWhen a function is called, it runs its code and sends a result back to the caller using a return statement. If no return statement is present, the function returns the None object automatically.\nyield for Generators:\nFunctions known as generators can use yield to send back a value and suspend execution, allowing them to produce a series of results over time.\nglobal and nonlocal:\nThe global statement declares that certain names are module-level variables, while nonlocal (introduced in Python 3) allows a function to assign to variables in an enclosing function\u0026rsquo;s scope. These keywords help manage variable scopes.\nArguments are Passed by Assignment (Object Reference):\nIn Python, arguments are passed by assignment. The caller and function share references to the same objects, but changing the reference inside the function does not affect the caller’s reference. However, modifying mutable objects can have an effect.\nNo Declarations for Arguments, Return Values, or Variables:\nPython does not require type declarations. A single function can be applied to different object types as long as the objects support the expected interface.\nThe def Statement The def statement creates a function object and assigns it to a name. Its general format is:\ndef \u0026lt;name\u0026gt;(arg1, arg2, ... argN): \u0026lt;statements\u0026gt; # Function body executed each time the function is called A function body often contains a return statement to send a result back to the caller:\ndef \u0026lt;name\u0026gt;(arg1, arg2, ... argN): ... return \u0026lt;value\u0026gt; # Returns \u0026lt;value\u0026gt; to the caller If there is no return statement, the function returns None by default.\ndef Executes at Runtime The def statement is executable code. When it runs, it creates a new function object and assigns it to a name. This means:\ndef can appear anywhere a statement is allowed (even nested inside other statements). The function is not defined until the def is executed. The function object can be assigned to other names, passed around, and can have attributes attached. For example, you can define a function conditionally:\nif test: def func(): # Define func this way ... else: def func(): # Or define func this other way ... # Call the version that was selected and built func() You can also assign a function to another name:\nothername = func # Assign function object to a new name func() # Call the original function Functions can have attributes attached to them:\ndef func(): ... func.attr = value # Attach an attribute to the function object A First Example: Definitions and Calls Definition Here’s an interactive definition of a function called times that returns the product of its two arguments:\ndef times(x, y): # Create and assign function \u0026#39;times\u0026#39; return x * y # Return the product of x and y when called When Python runs this def, it creates a new function object assigned to the name times.\nCalls After the function is defined, you can call it by passing arguments in parentheses:\ntimes(2, 4) # Call times with arguments 2 and 4; returns 8 This call passes two arguments to times. The function multiplies them and returns the result. You can also save the result:\nx = times(3.14, 4) # Save the result of 3.14 * 4 print(x) # Outputs: 12.56 Notice that Python functions are \u0026ldquo;typeless\u0026rdquo;—they work with any types that support the operations used in the function. For example:\ntimes(\u0026#39;Ni\u0026#39;, 4) # Repeats the string \u0026#39;Ni\u0026#39; four times, resulting in \u0026#39;NiNiNiNi\u0026#39; In this case, the * operator repeats a string rather than performing numeric multiplication.\nA Second Example: Intersecting Sequences Here is a function that finds the common items between two sequences. Packaging the loop inside a function makes the code reusable and easier to maintain.\nDefinition def intersect(seq1, seq2): res = [] # Start with an empty list for results for x in seq1: # Iterate over each element in seq1 if x in seq2: # Check if the element is in seq2 res.append(x) # Append common elements to the result list return res # Return the list of common elements Calls Once defined, call the function by passing two sequences:\ns1 = \u0026#34;SPAM\u0026#34; s2 = \u0026#34;SCAM\u0026#34; print(intersect(s1, s2)) # For strings, outputs: [\u0026#39;S\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;M\u0026#39;] The algorithm is simple: for every item in the first argument, if that item is also in the second, it is added to the result list. Although this function is not optimized for performance and does not remove duplicates, it demonstrates the basics of function definition and reuse.\nA more concise version using a list comprehension is:\nprint([x for x in s1 if x in s2]) # Outputs: [\u0026#39;S\u0026#39;, \u0026#39;A\u0026#39;, \u0026#39;M\u0026#39;] Polymorphism Revisited Like all functions in Python, intersect is polymorphic. It works on arbitrary types as long as the objects support the operations used (such as membership tests):\nx = intersect([1, 2, 3], (1, 4)) # Works with a list and a tuple print(x) # Outputs the common elements (if any) ","permalink":"/chapters/chapter-12/","summary":"\u003cp\u003eIn the previous part, we looked at basic procedural statements in Python. Here, we move on to explore a set of additional statements that we can use to create functions of our own. In simple terms, a function is a device that groups a set of statements so they can be run more than once in a program. Functions can compute a result value and allow us to specify parameters that serve as function inputs, which may differ each time the code is run. Coding an operation as a function makes it a generally useful tool that can be used in a variety of contexts.\u003c/p\u003e","title":"Chapter 12: Functions Basics"},{"content":"We will present the details behind Python’s scopes and arguments—the places where variables are defined and looked up. Like module files, scopes help prevent name clashes across your program’s code; names defined in one program unit don’t interfere with names in another. We’ll also see that scope usage can have a major impact on program maintenance; for example, overuse of globals is generally bad. On the plus side, scopes provide a way to retain state information between function calls and can sometimes offer an alternative to classes.\nPython Scope Basics When you use a name in a program, Python creates, changes, or looks up the name in a namespace—a place where names live. The term scope refers to this namespace; that is, the location of a name’s assignment in your source code determines its visibility. Functions add an extra namespace layer to minimize collisions among variables of the same name—by default, all names assigned inside a function belong only to that function’s namespace.\nArgument-Passing Basics Key points in passing arguments to functions:\nArguments are passed by automatically assigning objects to local variable names. Assigning to argument names inside a function does not affect the caller. Changing a mutable object argument in a function may impact the caller. Arguments and Shared References To illustrate argument-passing properties, consider the following code:\ndef f(a): # a is assigned to (references) the passed object a = 99 # Changes local variable a only b = 88 f(b) # a and b both initially reference 88 print(b) # b is not changed; outputs: 88 When arguments are passed mutable objects (like lists or dictionaries), in-place changes can persist after the function exits and affect the caller. For example:\ndef changer(a, b): # Arguments assigned references to objects a = 2 # Changes local name\u0026#39;s value only b[0] = \u0026#39;spam\u0026#39; # Changes shared object in place X = 1 L = [1, 2] # Caller changer(X, L) # Pass immutable and mutable objects print(X, L) # X is unchanged; L becomes [\u0026#39;spam\u0026#39;, 2] Another example shows that assignment to a local variable does not change the caller’s variable:\nX = 1 a = X a = 2 # Resets \u0026#39;a\u0026#39; only; \u0026#39;X\u0026#39; remains 1 print(X) # Outputs: 1 Simulating Output Parameters and Multiple Results Although Python doesn’t support \u0026ldquo;call by reference\u0026rdquo; argument passing, you can simulate it by returning tuples and assigning the results back to the original argument names:\ndef multiple(x, y): x = 2 # Changes local names only y = [3, 4] # Creates a new list for y return x, y # Return multiple new values in a tuple X = 1 L = [1, 2] X, L = multiple(X, L) # Assign returned values to caller\u0026#39;s names print(X, L) # Outputs: (2, [3, 4]) Argument Matching Syntax [Table Placeholder: Special Argument Matching Syntax]\n","permalink":"/chapters/chapter-13/","summary":"\u003cp\u003eWe will present the details behind Python’s scopes and arguments—the places where variables are defined and looked up. Like module files, scopes help prevent name clashes across your program’s code; names defined in one program unit don’t interfere with names in another. We’ll also see that scope usage can have a major impact on program maintenance; for example, overuse of globals is generally bad. On the plus side, scopes provide a way to retain state information between function calls and can sometimes offer an alternative to classes.\u003c/p\u003e","title":"Chapter 13: Scopes \u0026 Arguments"}]